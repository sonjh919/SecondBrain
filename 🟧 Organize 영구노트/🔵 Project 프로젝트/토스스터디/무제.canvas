{
  "edges": [
    {
      "id": "605b2611e81c8b4b",
      "styleAttributes": {},
      "fromNode": "e8627b9039ddbc6b",
      "fromSide": "right",
      "toNode": "848bcc27d8602789",
      "toSide": "left",
      "label": "서버는 이상 없음!\nDB 트랜잭션을 사용\n-> DB 문제?"
    },
    {
      "id": "5ed5227db64d618d",
      "styleAttributes": {},
      "fromNode": "848bcc27d8602789",
      "fromSide": "right",
      "toNode": "5003ce996216f1c1",
      "toSide": "left",
      "label": "Connection Pool 확인"
    },
    {
      "id": "18682300c7e9e3c4",
      "styleAttributes": {},
      "fromNode": "848bcc27d8602789",
      "fromSide": "bottom",
      "toNode": "6026e70a7117fad4",
      "toSide": "top",
      "label": "explain ㄱㄱ"
    },
    {
      "id": "45123084778c8e8d",
      "styleAttributes": {},
      "fromNode": "6026e70a7117fad4",
      "fromSide": "right",
      "toNode": "ca33b03d02082f28",
      "toSide": "left",
      "label": "시간이 오래 걸린다면?"
    },
    {
      "id": "69bb05a153383a45",
      "styleAttributes": {},
      "fromNode": "ca33b03d02082f28",
      "fromSide": "right",
      "toNode": "88d75d060026abb6",
      "toSide": "left",
      "color": "1",
      "label": "이미 인덱스 쓰고 있다면?"
    },
    {
      "id": "1099fd02ee63e270",
      "styleAttributes": {},
      "fromNode": "ca33b03d02082f28",
      "fromSide": "bottom",
      "toNode": "6d53aea8b7daeab0",
      "toSide": "top",
      "label": "db 용량 확인"
    },
    {
      "id": "186d7f07dd6ff76d",
      "styleAttributes": {},
      "fromNode": "88d75d060026abb6",
      "fromSide": "right",
      "toNode": "157d7fee0331c255",
      "toSide": "top"
    },
    {
      "id": "69e71569295fcf1c",
      "styleAttributes": {},
      "fromNode": "157d7fee0331c255",
      "fromSide": "bottom",
      "toNode": "55276dc05e107ce9",
      "toSide": "top"
    },
    {
      "id": "ea2cd869654cf414",
      "styleAttributes": {},
      "fromNode": "55276dc05e107ce9",
      "fromSide": "bottom",
      "toNode": "be18e43a71e2fc76",
      "toSide": "top"
    },
    {
      "id": "5ffcabef9265d34e",
      "styleAttributes": {},
      "fromNode": "be18e43a71e2fc76",
      "fromSide": "bottom",
      "toNode": "d0934b2b7cdf5342",
      "toSide": "top",
      "label": "그래서, 조각화 어떻게 확인함?"
    },
    {
      "id": "9f6983e4f21187a5",
      "styleAttributes": {},
      "fromNode": "d0934b2b7cdf5342",
      "fromSide": "bottom",
      "toNode": "97d761893ecc86b2",
      "toSide": "top",
      "label": "단편화 비율 계산!"
    },
    {
      "id": "882c822a4a398229",
      "styleAttributes": {},
      "fromNode": "97d761893ecc86b2",
      "fromSide": "right",
      "toNode": "2efa782288f0bdc8",
      "toSide": "left",
      "label": "그래서 리빌딩 방법은?"
    },
    {
      "id": "d68b47536bf60f75",
      "styleAttributes": {},
      "fromNode": "d0934b2b7cdf5342",
      "fromSide": "left",
      "toNode": "51f7a6936ef251ac",
      "toSide": "top"
    }
  ],
  "nodes": [
    {
      "file": "🟧 Organize 영구노트/🔵 Project 프로젝트/토스스터디/지연의 원인을 찾아라 (15점).md",
      "id": "e8627b9039ddbc6b",
      "type": "file",
      "styleAttributes": {},
      "x": -240,
      "y": -320,
      "width": 900,
      "height": 1060
    },
    {
      "id": "5003ce996216f1c1",
      "styleAttributes": {},
      "text": "**활성 커넥션 수와 최대 커넥션 수 비교:** 커넥션 풀의 최대치(maximumPoolSizemaximumPoolSize)에 근접하거나 도달한 상태에서 active connection이 계속 가득 차 있다면 부족\n\n-> ConnectionPool 늘리기!!\n\n(즉각적인 방법)",
      "type": "text",
      "x": 1840,
      "y": 110,
      "width": 440,
      "height": 200,
      "color": "1"
    },
    {
      "id": "848bcc27d8602789",
      "styleAttributes": {},
      "text": "### DB에서 문제가 있는지 확인하는 방법\n\n1. 트래픽이 집중될 때 P95 응답 시간이 급증하면, DB ConnectionPool이 모자른 것이 아닐까?\n2. 쿼리 실행 속도가 느릴 수도 있을 것 같다.",
      "type": "text",
      "x": 1060,
      "y": 80,
      "width": 480,
      "height": 260
    },
    {
      "id": "6026e70a7117fad4",
      "styleAttributes": {},
      "text": "쿼리 실행 시간 봐서 slow query 잡아내기!!",
      "type": "text",
      "x": 1170,
      "y": 520,
      "width": 260,
      "height": 100
    },
    {
      "id": "ca33b03d02082f28",
      "styleAttributes": {},
      "text": "인덱스 확인.\nexplain으로 스캔 범위 잡아낸다음에 range로 들어갈 수 있게 하기",
      "type": "text",
      "x": 1840,
      "y": 520,
      "width": 260,
      "height": 100,
      "color": "1"
    },
    {
      "id": "88d75d060026abb6",
      "styleAttributes": {},
      "text": "인덱스 조각화 비율 체크해서 인덱스를 리빌딩할 필요성이 있는지 확인해보고, 필요하면 리빌딩하기.",
      "type": "text",
      "x": 2400,
      "y": 520,
      "width": 260,
      "height": 100,
      "color": "1"
    },
    {
      "id": "55276dc05e107ce9",
      "type": "text",
      "text": "인덱스는 16KB 고정 크기의 페이지 단위로 관리되며, 인덱스 키 크기가 커져서 한 페이지에 인덱스 키를 많이 저장하지 못하면 여러 페이지에 나눠 저장",
      "styleAttributes": {},
      "x": 2270,
      "y": 880,
      "width": 980,
      "height": 60
    },
    {
      "id": "157d7fee0331c255",
      "type": "text",
      "text": "페이지: 데이터 저장과 인덱스 관리를 위한 기본 단위, 기본 16kb.\n\n",
      "styleAttributes": {},
      "x": 2530,
      "y": 700,
      "width": 460,
      "height": 60
    },
    {
      "id": "be18e43a71e2fc76",
      "type": "text",
      "text": "데이터가 여러 페이지에 흩어져 저장되면 인덱스 조각화(Fragmentation)가 발생할 수 있다. \n조각화가 심해지면 **인덱스 탐색 및 데이터 접근 성능 저하가 발생**한다.",
      "styleAttributes": {},
      "x": 2270,
      "y": 1020,
      "width": 980,
      "height": 60
    },
    {
      "id": "d0934b2b7cdf5342",
      "type": "text",
      "text": "```sql\nSELECT * FROM information_schema.tables WHERE table_schema = '데이터베이스명';\n```\n\n![[Pasted image 20250928224044.png]]",
      "styleAttributes": {},
      "x": 1915,
      "y": 1240,
      "width": 1690,
      "height": 440
    },
    {
      "id": "97d761893ecc86b2",
      "type": "text",
      "text": "### 단편화 비율 구하는 공식\n\n#### 단편화란?\n- **단편화(fragmentation)**는 저장 공간이 연속적으로 사용되지 않고, 중간중간에 빈 공간(사용되지 않는 공간)이 생기는 현상\n- 예를 들어, 테이블에서 데이터를 여러 번 삭제하거나 갱신하면, 실제 데이터가 차지하는 공간 사이사이에 **쓸 수 없는 빈 공간**이 남게 된다.\n\n단편화 비율(%) = (data_free / (data_length + index_length)) * 100\n\n- data_length는 데이터가 차지하는 공간 크기(바이트 단위)\n- index_length는 인덱스가 차지하는 공간 크기(바이트 단위)\n- data_free는 예약되어 있지만 실제로 사용되지 않는 공간 크기(바이트 단위)-> 삭제될때 마킹되는 공간(soft delete)\n\n**테이블 전체 공간 대비 빈 공간, 즉 사용되지 않는 공간이 차지하는 비율을 백분율로 산출**\n-> 단편화 비율이 높다는 것은 테이블 내에 상당한 양의 비효율적 공간이 존재함을 의미\n\n![[Pasted image 20250928224151.png]]\n\n```sql\nSELECT \n  table_schema, \n  table_name, \n  data_length, \n  index_length, \n  data_free, \n  (data_free / (data_length + index_length)) * 100 AS fragmentation_ratio \nFROM information_schema.tables \nWHERE table_schema = 'your_database' \n  AND table_name = 'your_table';\n\n```\n\n보통 조각화가 10%가 넘으면 효과가 확실하고, 5%면 고려할 수 있다.\n그러나, 전문 검색 인덱스라면 다음과 같은 이유로 5% 이하에서도 효과가 있을 수 있음!!\n\n1. 데이터 변경이 많음\n2. 인덱스 크기가 큼\n3. 삭제/갱신 후 인덱스 비효율\n-> 조각화가 빠르게 진행됨!!",
      "styleAttributes": {},
      "x": 2405,
      "y": 1840,
      "width": 710,
      "height": 980
    },
    {
      "id": "51f7a6936ef251ac",
      "type": "text",
      "text": "### 조각화?단편화?\n- **단편화(fragmentation)**는 저장 공간이 연속적으로 사용되지 않고, 중간중간에 빈 공간이 생기는 현상입니다. 이는 데이터뿐 아니라 인덱스에도 발생할 수 있습니다.\n    \n- **인덱스 조각화(index fragmentation)**는 인덱스(B+Tree 등) 페이지 내부에 데이터가 불균형하게 분포하거나, 삭제/갱신으로 인해 빈 공간이 많아져 인덱스가 여러 \"조각\"으로 나뉘는 현상을 말합니다\n\n\n-> **인덱스 조각화**는 인덱스에서 발생하는 단편화의 한 형태",
      "styleAttributes": {},
      "x": 1300,
      "y": 1760,
      "width": 560,
      "height": 340
    },
    {
      "id": "2efa782288f0bdc8",
      "type": "text",
      "text": "## OPTIMIZE TABLE (InnoDB)\n\n- InnoDB에서는 OPTIMIZE TABLE 명령어가 사실상 `ALTER TABLE ... FORCE` 명령과 동일하게 동작하여 테이블을 재구성합니다.\n- 테이블 데이터를 클러스터형 인덱스(Primary Key) 순서대로 재배치하여 단편화된 데이터와 인덱스를 정리하고, 삭제나 업데이트로 인해 남은 불필요한 공간을 회수합니다.\n- 인덱스 통계 정보도 갱신되어 옵티마이저가 최신 통계 기반으로 쿼리 계획을 세울 수 있게 돕습니다.\n- 작업 도중 임시 테이블을 생성해 데이터를 복제하며, 마지막에 원본 테이블을 교체하는 방식이라 락과 많은 I/O가 발생할 수 있습니다.    \n- InnoDB는 MVCC 구조이며 페이지 할당 방식 때문에 조각화 발생 빈도가 상대적으로 낮지만, 대량 삭제/갱신 이후 수동 최적화가 필요할 수 있습니다.\n\n```sql\nOPTIMIZE TABLE discussion;\n```\n    \n\n## 인덱스 리빌딩 (InnoDB)\n\n- 인덱스 리빌딩은 특정 인덱스(또는 모든 인덱스)를 재생성하는 작업으로, 단편화된 인덱스 페이지를 재정렬해 검색 성능을 개선합니다.\n- MySQL은 별도의 인덱스 리빌드 명령이 없으며, 인덱스 리빌드는 보통 ALTER TABLE을 통해 테이블 전체를 재생성하거나 DROP INDEX 후 ADD INDEX를 실행하는 방식으로 수행합니다.\n- 인덱스 리빌딩은 인덱스만 다시 만드는 것이지만, InnoDB에서 테이블 재빌드 작업은 자동으로 인덱스를 포함하여 전체 데이터를 재정렬하는 효과를 냅니다.\n- 인덱스 리빌딩은 OPTIMIZE TABLE의 하위 개념으로 볼 수 있으며, OPTIMIZE TABLE은 테이블 데이터와 인덱스를 통합적으로 최적화합니다.\n\n(단일)\n```sql\nALTER TABLE discussion DROP INDEX idx_discussion_date, ADD INDEX idx_discussion_date (discussion_date);\n```\n\n(전체)\n```sql\nALTER TABLE discussion ENGINE=InnoDB;\n```\n",
      "styleAttributes": {},
      "x": 3580,
      "y": 1940,
      "width": 960,
      "height": 780
    },
    {
      "id": "6d53aea8b7daeab0",
      "styleAttributes": {},
      "text": "샤딩/파티셔닝\n스케일 아웃/스케일 업 등등?\n\n돈들어서 별로일듯",
      "type": "text",
      "x": 1660,
      "y": 800,
      "width": 260,
      "height": 140
    }
  ],
  "metadata": {}
}