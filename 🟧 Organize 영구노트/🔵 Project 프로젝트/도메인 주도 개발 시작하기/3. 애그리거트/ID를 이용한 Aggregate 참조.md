#Architecture #DDD #Book


## Aggregate 참조
애그리거트 간의 참조는 필드를 통해 쉽게 구현할 수 있다. JPA를 사용하면 [[@ManyToOne]], [[@OneToOne]]과 같은 애노테이션을 이용해서 연관된 객체를 로딩하는 기능을 제공하고 있으므로 필드를 이용해서 다른 애그리거트를 쉽게 참조할 수 있다. 하지만 필드를 이용한 애그리거트 참조는 다음의 문제를 야기할 수 있다.

> [!summary]+ 
> + 편한 탐색 오용
> + 성능에 대한 고민
> + 확장 어려움

### 1. 편한 탐색 오용
한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다. 다음 코드처럼 구현의 편리함 때문에 다른 애그리거트를 수정하고자 하는 유혹에 빠지기 쉽다.

> [!caution]+ 
> 한 애그리거트 내부에서 다른 애그리거트에 접근할 수 있으면, 구현이 쉬워진다는 것 때문에 다른 애그리거트의 상태를 변경하는 유혹에 빠지기 쉽다.

```java
public class Order {
	private Orderer orderer;

	public void changeShippingInfo( ... ) {
		...
		// Member의 Address를 변경한다. 
		orderer.getCusotmer().changeAddress(newShippingInfo.getAddress());
	}
}
```

위와 같이 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 **의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.**

### 2. 성능에 대한 고민
JPA를 사용할 경우 참조한 객체를 [[지연 로딩]]과 [[즉시 로딩]]의 두 가지 방식으로 로딩할 수 있다.

### 3. 확장 어려움
초기에는 단일 서버에 단일 DBMS로 서비스를 제공하는 것이 가능하다. 문제는 사용자가 몰리기 시작하면서 도메인별로 시스템을 분리하기 시작한다. 이 과정에서 **하위 도메인마다 서로 다른 DBMS를 사용할 가능성이 높아진다.** 이는 더 이상 다른 [[Aggregate 루트]]를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 의미한다.

---

이런 세 가지 문제를 완화할 때 사용할 수 있는 것이 **ID를 이용하여 다른 애그리거트를 참조하는 것**이다. 애그리거트의 경계를 명확히 하고 **애그리거트 간 물리적인 연결을 제거**하게 된다.

> [!summary]+ 
> 1. 모델의 복잡도를 낮춰준다.
> 2. 애그리거트 간의 의존을 제거하므로 응집도를 높여준다.
> 3. 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 원척적으로 방지할 수 있다.
> 4. 애그리거트 별로 다른 구현 기술을 사용하는 것도 가능해진다.
> 5. 응용 서비스에서 필요한 애그리거트를 로딩하므로 [[지연 로딩]]과 동일한 결과를 만든다.

![[repoaggregate.png]]

## ID를 이용한 참조와 조회 성능
다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽어야 할 때 조회속도가 문제될 수 있다. ID 참조 방식을 사용하면서 N+1 조회와 같은 문제가 발생하지 않도록 하려면 **조회 전용 쿼리**를 이용하면 된다.

> [!example]+ 
> 데이터 조회를 위한 별도 DAO(Repository)를 만들고 DAO의 조회 메서드에서 조인을 이용해 한 번의 쿼리로 필요한 데이터를 로딩한다.

이때 조회 성능을 높이기 위해 **캐시**를 적용하거나 **조회 전용 저장소**를 따로 구성한다. 이 방법은 코드가 복잡해지는 단점이 있지만 시스템 처리량을 높일 수 있다는 장점이 있다.