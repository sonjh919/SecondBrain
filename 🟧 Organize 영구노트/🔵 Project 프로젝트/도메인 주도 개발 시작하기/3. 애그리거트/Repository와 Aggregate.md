#Architecture #DDD #Book

## Repository와 Aggregate
애그리거트는 개념적으로 하나이므로 **리포지터리는 애그리거트 전체를 저장소에 영속화**해야 한다. 

> [!example]+ 
> Order 애그리거트를 저장할 때 애그리거트 루트와 매핑되는 테이블뿐만 아니라 애그리거트에 속한 모든 구성요소를 위한 테이블에 데이터를 저장해야 한다.

새로운 애그리거트를 만들면 영속화하고, 사용하기 위해서는 저장소에서 읽어야 하므로 보통 2개의 메서드를 기본적으로 제공한다.

> [!summary]+ 
> + save : 애그리거트 저장
> + findById : ID로 애그리거트 구하기

어떤 기술을 이용하여 리포지터리를 구현하느냐에 따라 애그리거트의 구현도 영향을 받는다.

> [!example]+ 
> JPA를 사용하면 데이터베이스 관계형 모델에 객체 도메인 모델을 맞춰야 할 때도 있다.
> 
> 이 때는 밸류 타입인 도메인 모델을 @Component(JPA에서 밸류 타입을 매핑할 때 사용하는)가 아닌 @Entity를 이용해야 할 수도 있다.
> 
> 라고 책에 써져 있지만, [[@Embedded]]를 쓰는 것은 어떨까 싶다.

> [!tip]+ 
> RDBMS를 이용하여 리포지터리를 구현하면 트랜잭션을 이용해서 애그리거트의 변경이 저장소에 반영되는 것을 보장할 수 있다.