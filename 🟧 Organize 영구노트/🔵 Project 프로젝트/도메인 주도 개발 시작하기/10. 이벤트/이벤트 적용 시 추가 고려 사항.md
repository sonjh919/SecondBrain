#Architecture #DDD #Book

## 이벤트 적용 시 추가 고려 사항
1. 이벤트 발행 주체를 이벤트에 포함 시킬지 여부 ( e.q. 주문 도메인이 발행한 이벤트만 조회하기)
2. 포워더에서 **전송 실패를 얼마나 허용할 것인가?**
> [!tip]+ 
> 특정 이벤트에서 계속 실패하면 그 실패하는 이벤트 때문에 다른 이벤트가 실행이 안된다. 재전송 횟수 제한을 두거나 실패 이벤트를 따로 물리 저장소에 남긴다.

3. **이벤트 손실을 얼마나 허용할 것인지**이다. 이벤트 저장소를 사용한다면 이벤트 발생과 이벤트 저장이 한 트랜잭션에 묶이므로 트랜잭션에 성공하면 이벤트가 저장소에 보관되는 것을 보장할 수 있다.
4. 이벤트 순서가 중요한 경우에는 **이벤트 저장소**를 사용할 수 있다. 메시징 시스템은 순서를 보장하기가 꽤나 어렵다 (Kafka는 특히)
5. 이벤트 재처리에 대한 고민을 해볼 수 있다. 동일한 이벤트를 다시 처리해야 한다면 가장 쉬운 방법은 마지막으로 처리한 이벤트를 기억하고 있으면 된다. 즉 이벤트 핸들러를 **멱등성**으로 처리한다.

### 이벤트 처리와 DB 트랜잭션 고려
> [!example]+ 
> 주문 취소와 환불 기능을 다음과 같이 이벤트를 이용해서 구현했다고 하자.
> 
> + 주문 취소 기능은 주문 취소 이벤트를 발생시킨다.
> + 주문 취소 이벤트 핸들러는 환불 서비스에 환불 처리를 요청한다.
> + 환불 서비스는 외부 API를 호출해서 결제를 취소한다.

만약 여기서 주문 취소 기능에서 DB에 업데이트 시키는 부분이 실패해서 예외가 터졌다고 가정하자. 즉, 외부 시스템에 환불 요청은 보냈는데 DB에는 주문 완료 상태로 남아있는 문제가 발생할 수 있다.

이를 해결하기 위한 방법으로 **트랜잭션이 성공했을 때만 이벤트 핸들러를 실행**하는 방법이 있다.

스프링은 `@TransactionalEventListenter` 어노테이션을 지원한다. 이 어노테이션은 스프링 트랜잭션 상태에 따라 이벤트 핸들러를 실행할 수 있게 한다.

```java
@Async  
@TransactionalEventListener(  
    classes = OrderCanceledEvent.class,  
    phase = TransactionPhase.AFTER_COMMIT  
)  
public void handle(OrderCanceledEvent event) {  
    refundService.refund(event.getOrderNumber());  
}
```

phase 속성 값으로 `TransactionPhase.AFTER_COMMIT`을 지정했다. 이 값을 사용하면 스프링은 트랜잭션 커밋에 성공한 뒤에 핸들러 메서드를 실행한다. 즉, 중간에 예외가 터져서 트랜잭션이 롤백되면 핸들러 메서드를 실행하지 않게 된다.

이제 트랜잭션 실패에 대한 고민이 줄었으니 이벤트 처리 실패에 대해서 재처리 방식을 결정하면 된다.