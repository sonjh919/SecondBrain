---
---
#Algorithm
### 시간 복잡도(Big-O Notation)
+ 입력의 크기 N에 대해 최악의 경우 시간이 얼마나 걸릴지 나타내는 방법이다.

> [!tip]+ 
> 문제를 풀기 전, 풀이를 떠올린 후 시간 내 통과할 수 있는지 생각해보아야 한다!

### 1초가 걸리는 입력의 크기
+ 컴퓨터가 대략 **1초에 1억번 연산**한다고 생각하면 대략 맞다.
+ 문제를 풀기 전 시간 복잡도를 미리 계산해 보고 시간 안에 수행된다고 판단될 경우 구현하기!!

| 시간복잡도    | 1초당 입력크기             | 자주 나오는 N 크기                  |
| -------- | -------------------- | ---------------------------- |
| O(1)     | .                    |                              |
| O(logN)  | .                    |                              |
| O(N)     | 100,000,000 (1억)     | N <= 10,000,000 ~ 20,000,000 |
| O(NlogN) | 5,000,000 (5백만)      | N <= 100,000 ~ 1,000,000     |
| O(N^2)   | 10,000 (1만)          | N <= 2000 ~ 5000             |
| O(N^3)   | 500                  | N <= 500                     |
| ---      | 여기서부터 코테에 적용하기 까다롭다. | ---                          |
| O(2^N)   | 20                   |                              |
| O(N!)    | 10                   |                              |

---

> [!tip]+ 
> 대체로 logn은 탐색이고, nlogn은 정렬이다.
### logN 계산법
핵심은 **반으로 나누어 탐색하면서, 각 단계에서 검색 범위가 절반으로 줄어든다는 것**이다.
1. 이때 배열의 길이는 n → n/2 → n/4 → n/8 ...
2. k번째 단계에서 배열의 길이는 n/2^k
3. 탐색 종료 조건은 배열의 길이가 1이 될 때, 즉 n/2^k=1
4. 정리하면 logn = k

### NlogN 계산법
이 시간 복잡도는 특정 정렬 알고리즘이 **데이터를 정렬하는 데 필요한 시간이 데이터 크기 n에 비례**하며, 동시에 **각 단계에서 로그 비율로 데이터 크기를 줄이기 때문**에 나타난다.

#### 1. 분할 단계
1. 배열을 반으로 나누어 두 개의 하위 배열로 분할한다. 재귀적으로 계속된다.
2. 배열의 크기가 n에서 n/2, n/4 ...로 되며, 배열이 1개의 원소만 남을 때 까지 분할한다.
3. 분할 단계의 깊이는 logn에 비례한다.

#### 2. 병합 단계
1. 분할된 배열을 병합하는 과정에서 정렬을 하기 때문에 각 단계마다 배열의 크기 n에 비례하는 시간이 필요하다.

즉, 분할과 병합 과정을 고려하여 전체 지산 복잡도는 NlogN이 된다.
### 시간 복잡도 계산
1. 상수는 버린다.
2. 두가지 항이 있을 때 변수가 같으면 큰 것만 빼고 다 버린다.
3. 두가지 항이 있을 때 변수가 다르면 놔둔다.

```
O(3N^2) = O(N^2)
O(5)=O(1)
O(N^2+N) = O(N^2)
O (N^2 + M)
```
