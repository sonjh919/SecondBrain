#Architecture #DDD #Book

## 오프라인 선점 잠금
> [!example]+ 
> 아틀라시안 컨플루언스는 문서 편집 시 누군가 먼저 편집을 하는 중이면 수정중 안내문구를 보여준다. 사전 충돌 여부를 알려주지만 동시에 수정하는 것을 막지는 않는다.

더 엄격하게 데이터 충돌을 막고 싶다면 **누군가 수정화면을 보고 있을 경우 수정 화면 자체를 실행하지 못하도록** 해야 한다. 한 트랜잭션 범위에서만 적용되는 선점 잠금 방식이나 나중에 버전 충돌을 확인하는 비선점 잠금 방식으로는 이를 구현할 수 없다. 이때 필요한 것이 **오프라인 선점 잠금 방식**이다.

단일 트랜잭션에서 동시 변경을 막는 선점 잠금 방식과 달리 오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다. **첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제한다. 잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없다.**


> [!example]+ 
> 수정 기능은 보통 두 개의 트랜잭션으로 구성된다. 첫 번째 트랜잭션을 폼을 부여주고, 두 번째 트랜잭션은 데이터를 수정한다. 오프라인 선점 잠금에서는 폼 요청 과정에서 잠금을 선점하고(과정 1), 수정과정에서 잠금을 해제한다(과정 3). 이미 잠금을 선점한 상태에서 다른 사용자가 폼을 요청하면 과정 2처럼 잠금을 구하지 못해 에러 화면을 보게 된다.
> ![[offlinepessimisticlock.png]]


### 오프라인 선점 방식 유효시간
사용자가 잠금을 해제하지 않고 프로그램을 종료하면 어떻게 될까? 이런 경우 영원히 잠금을 구할 수 없는 상황이 발생하므로 오프라인 선점 방식은 잠금 유효 시간을 가져야 한다.

보통 일정 주기로 유효 시간을 증가시키는 방법이 필요하다.

> [!example]+ 
> 수정 폼에서 1분 단위로 Ajax 호출을 하여 잠금 유효 시간을 1분씩 증가시키는 방법이 있다.


## 오프라인 선점 잠금을 위한 LockManager
오프라인 선점 잠금은 크게 4가지의 기능이 필요하다.

> [!summary]+ 
> 1. 잠금 선점 시도
> 2. 잠금 확인
> 3. 잠금 해제
> 4. 잠금 유효시간 연장

이 기능을 위해 LockManager를 사용한다. 다음 2가지로 구현할 수 있다.

> [!summary]+ 
> 1. [[LockManager 인터페이스]]
> 2. DB : Lock 테이블을 만들고 데이터를 담을 LockData 생성 후 LockManager 구현하기

