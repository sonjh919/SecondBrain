#jpa 

## 변경 감지 (Dirty Checking)
- 영속성 컨텍스트에 저장된 Entity가 변경될 때마다 Update SQL이 쓰기 지연 저장소에 저장된다면?
+ 하나의 Update SQL로 처리할 수 있는 상황을 여러번 Update SQL을 요청하게 되기 때문에 비효율적이다.
+ JPA는 **update 메서드를 지원하지 않는다!**


### JPA의 Update 처리

![[updatechecking.png]]
1. JPA는 영속성 컨텍스트에 Entity를 저장할 때 최초 상태(LoadedState, **스냅샷**)를 저장한다.
2. 트랜잭션이 commit되고 [[flush]]가 호출되면 Entity의 현재 상태와 저장한 최초 상태를 비교한다.
3. 변경 내용이 있다면 Update SQL을 생성하여 [[쓰기 지연 저장소]]에 저장하고 모든 쓰기 지연 저장소의 SQL을 DB에 요청한다.
4. 마지막으로 DB의 트랜잭션이 commit 되면서 반영된다.

- 따라서 변경하고 싶은 데이터가 있다면 먼저 데이터를 조회하고 해당 Entity 객체의 데이터를 변경하면 자동으로 Update SQL이 생성되고 DB에 반영된다.
+ 이러한 과정을 변경 감지, Dirty Checking이라 부른다.

> [!note]+ 스냅샷
> JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이를 스냅샷이라 한다.


> [!tip]+ 
> 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.

### JPA 수정 기본전략
JPA의 기본 전략은 일부 필드만 변경점이 있어도 엔티티의 모든 필드를 업데이트한다. DB에 보내는 데이트 전송량이 증가한다는 단점이 있지만, 다음과 같은 장점도 있다.

만약 필드가 많거나 저장되는 내용이 너무 많다면, 수정된 데이터만 사용하여 동적으로 UPDATE SQL을 생성하는 전략을 사용하자. (@DynamicInsert, @DynamicUpdate)

> [!tip]+ 
> 컬럼이 대략 30개 이상이 된다면 @DynamicUpdate를 사용한 동적 수정 쿼리가 더 빠르다고 한다. 하지만 30개 이상이면 보통 테이블 설계상 책임이 적절히 분리되지 않았을 가능성이 높다..

> [!info]+ 
> 1. 모든 필드를 사용하면 수정 쿼리가 항상 같기 때문에, 어플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용할 수 있다.
> 2. 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한번 파싱된 쿼리를 재사용할 수 있다.