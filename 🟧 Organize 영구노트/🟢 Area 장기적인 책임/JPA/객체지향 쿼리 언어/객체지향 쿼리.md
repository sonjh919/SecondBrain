#jpa 

## 객체지향 쿼리의 필요성
엔티티 조회에는 크게 두가지 방법이 있다.

> [!summary]+ 
> 1. 식별자로 조회 : EntityManager.find()
> 2. 객체 그래프 탐색 : ex)a.getB().getC()

이 기능만으로는 모든 검색을 다 할 수 없다. 좀 더 복잡한 방식이 필요한데, 그렇다고 모든 엔티티를 메모리에 올려둘 수도 없다. **결국 데이터는 데이터베이스에 있다.** 고로 [[SQL]]로 필요한 내용을 최대한 걸러서 조회해야 하고, 결국 **검색 조건이 포함된 SQL**을 사용해야 한다. 하지만 [[ORM]]을 사용하면 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 개발하므로 검색도 테이블이 아닌 엔티티 객체를 대상으로 하는 방법이 필요하다.

이 문제를 해결하기 위해 JPQL(Java Persistence Query Language)이 만들어졌다. 객체지향 SQL인 JPQL을 통해 검색이 가능하다. 하지만 JPA는 JPQL 이외에도 다양한 검색 방법을 제공한다.

## 객체지향 쿼리의 종류
+ 어떤 방법을 사용하든 JPQL에서 모든 것이 시작한다.

> [!summary]+ JPA 공식 지원
> + [[JPQL]]
> + [[Criteria]] : JPQL을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음
> + [[네이티브 SQL]] : JPA에서 JPQL 대신 직접 SQL을 사용할 수 있다.

> [!summary]+ 공식 지원은 아니지만 유용한 기술
> + [[QueryDSL]] : Criteria 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음. 비표준 오픈소스 프레임워크이다.
> + JDBC & SQL Mapper 직접 사용


> [!caution]+ 
> JDBC나 Mybatis를 JPA와 함께 사용하면 JPA를 우회하는 SQL에 대해서는 JPA가 전혀 인식하지 못하기 때문에 [[영속성 컨텍스트]]를 적절한 시점에 강제로 [[flush]]해야 한다.  이는 데이터 무결성과도 관련이 있으며, 강제 flush를 통해 **데이터베이스와 영속성 컨텍스트를 동기화**하도록 하자.