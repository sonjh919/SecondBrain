#DataBase 


## 데이터 정합성과 무결성
DataBase는 데이터를 영속적으로 저장하고 있는 시스템이다. 이런 시스템은 같은 자원(데이터)에 대해서 동시에 접근하는 경우가 생길 수 밖에 없는데, 이럴 경우 데이터의 정합성과 무결성을 유지해야 할 필요가 있다. 이때 사용하는 공통적인 방법이 **Lock**이다.

## Lock
> [!note]+ Lock
> **트랜잭션 처리의 순차성을 보장하기 위한 방법**

## Lock의 종류
> [!summary]+ 
> 1. Shared Lock(공유 락)
> 2. Exclusive Lock(베타적 락)
> 3. Row Lock(행 락)
> 4. Table Lock(테이블 락)
> 5. Page Lock(페이지 락)
> 6. Shared with Intent Exclusive Lock, S-IX(베타 락)
> 7. Exclusive with Intent Shared Lock, X-IS(베타 락)

### 1. Shared Lock(공유 락)
- 여러 트랜잭션이 읽기 작업을 수행할 때 사용된다.
- 공유 락이 설정되면 다른 트랜잭션도 동일한 데이터를 읽을 수 있지만, 해당 데이터를 수정하는 작업은 막힌다.
### 2. Exclusive Lock(베타적 락)
- 트랜잭션이 데이터를 수정할 때 사용된다.
- 배타적 락이 설정되면 다른 트랜잭션은 해당 데이터에 대한 읽기 및 쓰기 작업이 불가능해진다.
### 3. Row Lock(행 락)
데이터베이스에서 특정 행(row)에 대한 락을 설정합니다. 다른 트랜잭션이 해당 행을 수정하는 것을 방지한다.
### 4. Table Lock(테이블 락)
전체 테이블에 대한 락을 설정합니다. 한 트랜잭션이 테이블을 수정하는 경우 다른 트랜잭션은 해당 테이블의 모든 작업을 수행할 수 없다.
### 5. Page Lock(페이지 락)
데이터베이스에서 페이지 단위로 락을 설정한다. 페이지는 일반적으로 여러 행을 포함하고 있다. 페이지 락은 해당 페이지의 데이터에 대한 접근을 제어한다.
### 6. Shared with Intent Exclusive Lock, S-IX(베타 락)
공유 락과 배타적 락을 동시에 사용할 때 트랜잭션이 걸리는 락이다. 다른 트랜잭션에게 공유 락을 허용하고, 트랜잭션이 데이터를 수정하려 할 때 배타적 락으로 업그레이드된다.
### 7. Exclusive with Intent Shared Lock, X-IS(베타 락)
배타적 락과 공유 락을 동시에 사용할 때 트랜잭션이 걸리는 락이다. 다른 트랜잭션에게 배타적 락을 허용하고, 트랜잭션이 데이터를 읽으려 할 때 공유 락으로 업그레이드된다.

## Lock을 설정하는 방식
> [!summary]+ 
> 1. Pessimistic Lock, [[선점 잠금]], 비관적 락
> 2. Optimistic Lock, [[비선점 잠금]], 낙관적 락

## Pessimistic Lock
데이터에 Lock을 걸어서 정합성을 맞추는 방법.
### Spin Lock
특정 데이터에 대한 접근을 시도할 때 다른 스레드가 해당 락을 해제할 때까지 반복적으로 락을 요청하며, 락이 해제될 때까지 무한히 반복한다. 이 과정에서 대기 시간이 없으며, 계속해서 락을 요청하고 해제하며 무한 루프를 돌기 때문에 "스핀" 락이라는 이름이 붙었다.

## Optimistic Lock
레코드에 버전을 부여해서 조회와 갱신시 버전 비교를 통해서 정합성을 맞추는 방법.
### 분산락(RedLock)
분산락([[RedLock]]) 참조.