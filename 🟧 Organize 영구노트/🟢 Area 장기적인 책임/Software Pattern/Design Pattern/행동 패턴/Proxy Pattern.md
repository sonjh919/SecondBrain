#SoftwarePattern #DesignPattern

## 프록시 패턴(Proxy Pattern)
프록시(Proxy)를 번역하면 **대리자, 대변인**의 의미를 갖고 있다. 대리자, 대변인은 **누군가를 대신해서 그 역할을 수행하는 존재**이다. 이는 프로그램에도 똑같이 적용된다. 즉, 프록시에게 **어떤 일을 대신 시키는 것**이다. 실제로 프록시 객체에서 추가적인 로직을 처리한 후 대상 객체에 접근할 수 있다.

어떤 객체를 사용하고자 할때, **객체를 직접적으로 참조하는 것이 아닌 해당 객체를 대항하는 객체를 통해 대상 객체에 접근**하는 방식을 사용하며, 원래 객체에 대한 접근을 제어한다. 이 때 프록시 객체는 **실제 객체에 대한 참조(target)을 보관**한다.

이렇게 되면 해당 객체가 메모리에 존재하지 않아도 기본적인 정보를 참조하거나 설정할 수 있고, 실제 객체의 기능이 필요한 시점까지 객체의 생성을 미룰 수 있다.


> [!info]+ 
> 일반적으로 프록시는 **다른 무언가와 이어지는 인터페이스 역할을 하는 클래스**를 의미한다.
![[proxy 1.png]]

## 프록시 패턴을 쓰는 이유?
> [!note]+ 목적
> + **제어의 흐름을 변경**하거나 **별도의 로직 처리**를 목적으로 한다.
> + 클라이언트가 받는 반환값을 특별한 경우가 아니면 변경하지 않는다.

그냥 객체를 이용하면 되지, 번거롭게 대리자를 통해 이용하는 이유는 무엇일까? 대상 클래스가 민감한 정보를 가지고 있거나 인스턴스화 하기에 무겁거나 추가 기능을 가미하고 싶은데, **원본 객체를 수정할 수 없는 상황일 때를 극복**하기 위해서 이다.

## 프록시 패턴의 장단점
> [!summary]+ 장점
> 1. **보안** : 프록시는 클라이언트가 작업을 수행할 수 있는 권한이 있는지 확인할 수 있다.
> 2. **캐싱** : 프록시가 내부 캐시를 유지하여 데이터가 캐시에 아직 존재하지 않는 경우에만 대상에서 작업이 실행되도록 한다.
> 3. **데이터 유효성 검사** : 프록시가 입력을 대상으로 전달하기 전에 유효성을 검사한다.
> 4. **지연 초기화** : 대상의 생성 비용이 비싸다면 프록시는 그것을 필요로 할 때 까지 연기할 수 있다.
> 5. **로깅** : 프록시는 메소드 호출과 상대 매개 변수를 인터셉트하고 이를 기록한다.
> 6. **원격 객체** : 프록시는 원격 위치에 있는 객체를 가져와 로컬처럼 보이게 할 수 있다.

> [!summary]+ 단점
> 1. 객체 생성 시 한 단계를 거치므로, 빈번한 객체 생성이 필요한 경우 성능이 저하될 수 있다. (자바에서는 리플렉션에서 제공하는 동적 프록시 기법으로 해결할 수 있다.)
> 2. 프록시 내부에서 객체 생성을 위해 스레드가 생성, 동기화가 구현되어야 하는 경우 성능이 저하될 수 있다.
> 3. 가독성이 떨어질 수 있다.


## 프록시 패턴의 종류
Proxy 패턴은 단순하면서도 자주 쓰이는 패턴이며, 그 활용 방식도 다양하다. 같은 프록시 객체라도 어떠한 로직을 짜느냐에 따라 그 활용도는 천차만별이 된다. Proxy 패턴의 기본형을 어떤 방식으로 변형하느냐에 따라 프록시 종류가 나뉘어지게 된다.

### 기본형 프록시(Normal Proxy)
```java
interface ISubject {
    void action();
}

class RealSubject implements ISubject {
    public void action() {
        System.out.println("원본 객체 액션 !!");
    }
}
```

```java
class Proxy implements ISubject {
    private RealSubject subject; // 대상 객체를 composition

    Proxy(RealSubject subject) {
        this.subject = subject;
    }

    public void action() {
        subject.action(); // 위임
        /* do something */
        System.out.println("프록시 객체 액션 !!");
    }
}

class Client {
    public static void main(String[] args) {
        ISubject sub = new Proxy(new RealSubject());
        sub.action();
    }
}
```
### 가상 프록시(Virtual Proxy)
- 지연 초기화 방식
- 가끔 필요하지만 항상 메모리에 적재되어 있는 무거운 서비스 객체가 있는 경우
- 실제 객체의 생성에 많은 자원이 소모 되지만 사용 빈도는 낮을 때 쓰는 방식이다.
- 서비스가 시작될 때 객체를 생성하는 대신에 **객체 초기화가 실제로 필요한 시점에 초기화될수 있도록 지연**할 수 있다.

```java
class Proxy implements ISubject {
    private RealSubject subject; // 대상 객체를 composition

    Proxy() {
    }

    public void action() {
    	// 프록시 객체는 실제 요청(action(메소드 호출)이 들어 왔을 때 실제 객체를 생성한다.
        if(subject == null){
            subject = new RealSubject();
        }
        subject.action(); // 위임
        /* do something */
        System.out.println("프록시 객체 액션 !!");
    }
}

class Client {
    public static void main(String[] args) {
        ISubject sub = new Proxy();
        sub.action();
    }
}
```

### 보호 프록시(Protection Proxy)
- 프록시가 대상 객체에 대한 자원으로의 엑세스 제어(접근 권한)
- 특정 클라이언트만 서비스 객체를 사용할 수 있도록 하는 경우
- 프록시 객체를 통해 클라이언트의 자격 증명이 기준과 일치하는 경우에만 서비스 객체에 요청을 전달할 수 있게 한다.

### 로깅 프록시(Logging Proxy)
- 대상 객체에 대한 로깅을 추가하려는 경우
- 프록시는 서비스 메서드를 실행하기 전달하기 전에 로깅을 하는 기능을 추가하여 재정의한다.

### 원격 프록시(Remote Proxy)
- **프록시 클래스는 로컬**에 있고, **대상 객체는 원격 서버**에 존재하는 경우
- 프록시 객체는 네트워크를 통해 클라이언트의 요청을 전달하여 네트워크와 관련된 불필요한 작업들을 처리하고 결과값만 반환
- 클라이언트 입장에선 프록시를 통해 객체를 이용하는 것이니 원격이든 로컬이든 신경 쓸 필요가 없으며, **프록시는 진짜 객체와 통신을 대리**하게 된다.
### 캐싱 프록시(Caching Proxy)
- 데이터가 큰 경우 캐싱하여 재사용을 유도한다.
- 클라이언트 요청의 결과를 캐시하고 이 캐시의 수명 주기를 관리한다.
