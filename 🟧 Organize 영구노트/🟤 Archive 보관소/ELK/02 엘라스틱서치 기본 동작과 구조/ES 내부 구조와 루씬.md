#Elasticsearch 

## ES 내부 구조와 루씬
ES는 아파치 루씬을 코어 라이브러리로 사용하고 있다.

> [!info]+ 루씬
> 문서를 색인하고 검색하는 라이브러리


## 루씬 flush
문서 색인 요청이 들어오면 루씬은 문서를 분석해서 역색인을 생성한다. 최초 생성 시에는 메모리 버퍼에 들어간다. 문서 색인, 업데이트, 삭제 등의 작업이 수행되면 루씬은 이러한 변경들을 메모리에 들고 있다가 주기적으로 디스크에 flush한다.

루씬은 색인한 정보를 파일로 저장하기 때문에 루씬에서 검색하려면 먼저 파일을 열어야 한다.

> [!important]+ 
> 루씬은 파일을 연 시점에 색인이 완료된 문서만 검색할 수 있다. 이후 색인에 변경사항이 발생했고, 그 내용을 검색 결과에 반영하고 싶다면 새로운 파일을 열어야 한다.

### refresh
1. ES는 내부적으로 루씬의 `DirectoryReader` 클래스를 이용해 파일을 열고 루씬의 색인에 접근할 수 있는 `IndexReader` 객체를 얻는다.
2. ES는 변경 내용을 검색에 반영하기 위해 루씬의 `DirectoryReader.openIfChanged`를 호출해 변경 사항이 적용된 새 `IndexReader`를 열어준 뒤 기존 `IndexReader`를 안전하게 닫는다.

Refresh 단계까지 온 데이터가 검색 대상이 된다. 어느 정도 비용이 있는 작업이기 때문에 ES는 색인이 변경될 때마다 refresh를 수행하지 않고 적절한 간격마다 주기적으로 실행한다.

> [!tip]+ 
> ES의 refresh API를 호출하면 필요에 따라 명시적으로 refresh 작업을 수행할 수도 있다.


## 루씬 commit
루씬의 flush는 시스템의 페이지 캐시에 데이터를 넘겨주는 것까지만 보장할 뿐 디스크에 파일이 실제로 안전하게 기록되는 것까지 보장하지 않는다. **따라서 루씬은 fsync 시스템 콜을 통해 주기적으로 커널 시스템의 페이지 캐시 내용과 실제로 디스크에 기록된 내용의 싱크를 맞추는 작업을 수행**한다. 이를 루씬 commit이라 한다.

ES의 flush 작업은 내부적으로 이 루씬 commit을 거친다. flush는 refresh보다 훨씬 비용이 드는 작업이기 때문에 마찬가지로 적절한 주기로 수행되며, 명시적으로 수행할 수도 있다.

> [!warning]+ 
> fsync 중 하드웨어 캐시를 사용하는 환경에서 실패가 나는 상황까지 데이터 정합성을 보장하지는 않는다.

> [!faq]+ fsync
> 변경 파일을 하드 디스크에 저장되도록 요청하며, 저장이 될 때까지 기다린다.
## 세그먼트
앞의 작업을 거쳐 디스크에 기록된 파일들이 모이면 세그먼트라는 단위가 된다. **이 세그먼트가 루씬의 검색 대상**이다. 세그먼트는 immutable 데이터로 구성되어 있으며, 새 문서가 들어오면 새 세그먼트가 생성된다. 기존 문서를 삭제하는 경우 삭제 플래그만 표시해 둔다. 기존 문서에 업데이트가 발생한 경우에는 삭제 플래그를 표시하고 새 세그먼트를 생성한다.

루씬 검색은 모든 세그먼트를 대상으로 수행된다. 불변인 세그먼트 개수를 무작정 늘려갈 수 없기 때문에 루씬은 중간중간 적당히 **세트먼트의 병합**을 수행한다. 이때 삭제 플래그가 표시된 데이터를 실제로 삭제하는 작업도 수행한다.

세트먼트 병합은 비싼 작업이지만 일단 병합을 하고 나면 검색 성능의 향상을 기대할 수 있다.
`forcemerge API`를 통해 명시적으로 병합을 수행할 수도 있다. 다만 이것은 더이상 추가적인 데이터 색인이 없을 것이 보장될 때 수행해야 좋다.

## 루씬 인덱스와 ES 인덱스
여러 세그먼트가 모이면 하나의 루씬 인덱스가 된다. 루씬은 이 인덱스 내에서만 검색이 가능하다.
**ES 샤드는 이 루씬 인덱스 하나를 래핑**한 단위다.

ES 샤드 여러 개가 모이면 ES 인덱스가 된다. ES 레벨에서는 여러 샤드에 있는 문서를 모두 검색할 수 있다. 새 문서가 들어오면 해당 내용을 라우팅하여 여러 샤드에 분산시켜 저장, 색인한다. 이후 클라이언트가 ES에 검색 요청을 보내면 ES는 해당하는 각 샤드를 대상으로 검색을 한 뒤 그 결과를 모아 병합하여 최종 응답을 만든다. 이런 구조를 통해 루씬 레벨에서는 불가능한 분산 검색을 ES 레벨에서는 가능하게 만들었다.

## translog
ES에 색인된 문서들은 루씬 commit까지 완료되어야 디스크에 안전하게 기록된다. 하지만 문서의 변경사항마다 commit을 수행하기에는 너무 큰 비용이 들고, 모아서 한다면 장애 발생 시 데이터 유실 우려가 있다. 이 문제를 해결하기 위해 ES 샤드는 모든 작업마다 translog라는 작업 로그를 남긴다.

translog는 색인, 삭제 작업이 루씬 인덱스에 수행된 직후에 기록된다. translog 기록까지 끝난 이후에야 작업 요청이 성공적으로 승인된다.

장애 발생 시 ES는 샤드 복구 단계에서 translog를 읽는다. translog 기록은 성공했지만 루씬 commit에 포함되지 못했던 작업 내용이 있다면 샤드 복구 단계에서 복구된다.

translog에는 디스크에 fsync된 데이터만 보존된다. 클라이언트가 색인, 삭제, 업데이트 등의 요청을 보낼 때 ES는 translog에 성공적으로 fsync되었을 때만 성공을 보고한다.

> [!caution]+ 
> translog가 너무 커지면 샤드 복구에 오랜 시간이 걸리게 된다. 이를 방지하고자 translog의 크기를 적절히 유지해준다. 