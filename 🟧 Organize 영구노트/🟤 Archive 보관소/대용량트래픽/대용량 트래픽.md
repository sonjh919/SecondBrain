
## 물리적 관점
**제일 중요한 키워드는 분산!!!!** -> 동기화 생각하기!
scale up : 비싼 비용 / scale out : 대부분 선택
장비 증설로 대응
온디맨드(On-Demand)
램 또는 cpu

![[Pasted image 20240201191421.png]]

### 어떤 서버 선택?
대략적 확인 방법
대역폭이 중요! = 네트워크 흐름을 얼마나 받을 수 있나?

대역폭(mbps : b는 bit) 계산
550kb당 1요청 -> 0.55mb
2만명이 1분(60초)동안

0.55 x 20000 x 1회 -> 11000mb -> 11gb
11gb x 8 /60초 : 1.46gbps -> 1460mbps


트래픽은 대역폭!(단 cpu랑 ram이 request 처리 잘된다는 가정)

### scale out
로드 밸런서 : 부하 분산! 
elb(elastic load balancer) 
Alb(Application Load Balancer) : 서버 트래픽 분산
autoscaling : 서버 사이즈를 자동으로 조절

쿠버네틱스의 hpa : pod(도커 이미지화된 것, aws의 ec2와 비슷)

![[Pasted image 20240201193341.png]]

## db
(대용량 데이터 다루기)
select은 인덱싱이 있어서 그나마 낫다

![[Pasted image 20240201193601.png]]

### sharding(여러 개의 서버)
같은 테이블이지만 대용량이면 한번에 다 찾기 힘들기 때문에(한 테이블에 10억개면 힘들다) 데이터 종류에 따라 ex) 연도별로 db 나누기, 인덱스별로 db 나누기

### partitioning(하나의 서버)
수평 쪼개기 하나의 서버에서 샤딩과 비슷한 방법
수직 쪼개기(정규화)

## 인덱스(db)
![[Pasted image 20240201194234.png]]
인덱스 보는 법

explain + select쿼리
explain : 내가 쿼리를 던졌을 때의 계획

![[Pasted image 20240201194340.png]]
type과 row만 보면 됨
type all : full scan, index를 안탔다는 증거
전체 return 값: row수 다 곱한 값

**인덱스를 잘 설정해야 한다!!!**
#### 인덱스 설정하기
1. 쿼리 패턴 분석 : 실제로 자주 사용되는 쿼리에서 어떤 컬럼이 자주 검색되는지 분석 후 해당 컬럼에 인덱스 추가(자주 사용되는 WHERE, JOIN, GROUP BY, ORDER BY)등의 절에 인덱스 추가
2. 단일 컬럼 vs 복합 인덱스 : 한개 컬럼으로 인덱스 vs 여러 조건 동시에 사용하는 쿼리(ex날짜+장소)
3. 읽기는 유리하지만, 쓰기가 많으면 성능 저하!

## cache
램

**(서버에서) 캐싱한다 -> 램에 저장하는 것**
일반적으로 램의 레지스트리에 캐싱하는 것이 빠르다.

![[Pasted image 20240201195712.png]]

db는 **네트워크 커넥션을 하는 것 자체가 io 리소스를 많이 잡아먹는 행위**

대용량이면 커넥션 자체로 엄청난 용량을 먹음. 커넥션 리소스에 한계가 있음.
redis : 실무에서 제일 많이 쓰는 캐싱 어플리케이션

redis면 커넥션을 안거침!

캐시를 붙이면 속도 차이가 어마어마하게 난다!

mysql vs redis 속도 테스트

## CDN (contents delivery network)
+ 넷플에서 쓰는거
+ CDN은 전 세계에 분산된 여러 서버(캐시 서버 또는 엣지 서버)에 콘텐츠를 미리 저장해 두고, 사용자가 콘텐츠를 요청할 때 **가장 가까운 서버**에서 해당 콘텐츠를 제공함으로써 로딩 시간을 단축
![[Pasted image 20240201200204.png]]

mono(은행! 은행은 mono를 벗어날 수 없다(core 여/수)) vs msa

**msa 자체로도 트래픽 분산 효과!**
![[Pasted image 20240201201104.png]]