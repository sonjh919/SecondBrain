{
	"edges":[
		{
			"fromNode":"8396d4281e45d6a3",
			"fromSide":"bottom",
			"id":"3d0a29cce3ca7601",
			"label":"객체지향의 목적은?",
			"styleAttributes":{},
			"toNode":"f7c860d7863b89a9",
			"toSide":"top"
		},
		{
			"fromNode":"f7c860d7863b89a9",
			"fromSide":"bottom",
			"id":"cecef697f8197212",
			"label":"유지보수가 좋으려면?",
			"styleAttributes":{},
			"toNode":"6bc890568fcbd4fd",
			"toSide":"top"
		},
		{
			"fromNode":"6bc890568fcbd4fd",
			"fromSide":"bottom",
			"id":"6fe595ccf0839263",
			"label":"변경이 용이하다?",
			"styleAttributes":{},
			"toNode":"10b3da348a2c9317",
			"toSide":"top"
		},
		{
			"fromNode":"10b3da348a2c9317",
			"fromSide":"bottom",
			"id":"f089001a8eb2a3fc",
			"label":"그럼 이러한 설계는 어떤 설계가 해당될까?",
			"styleAttributes":{},
			"toNode":"ba6c3ff1670db01f",
			"toSide":"top"
		},
		{
			"fromNode":"ce404c0b3cfdd5a3",
			"fromSide":"left",
			"id":"238e6cf32a9ceb36",
			"label":"책임, 역할 협력에서의 \n책임과 같은 뜻인가?",
			"styleAttributes":{},
			"toNode":"d7089d5a4c373808",
			"toSide":"right"
		},
		{
			"fromNode":"ba6c3ff1670db01f",
			"fromSide":"bottom",
			"id":"bd371e90aee3c037",
			"label":"객체가 하나의 변경 이유를\n가지려면?",
			"styleAttributes":{},
			"toNode":"ce404c0b3cfdd5a3",
			"toSide":"top"
		},
		{
			"fromNode":"ce404c0b3cfdd5a3",
			"fromSide":"right",
			"id":"e50b9af4648e2943",
			"label":"하나의 책임만 \n담당할 수 있는 \n객체는?",
			"styleAttributes":{},
			"toNode":"09748f6b032b8b1e",
			"toSide":"left"
		},
		{
			"fromNode":"09748f6b032b8b1e",
			"fromSide":"right",
			"id":"0d0dd36c1977d6bc",
			"label":"응집도란?",
			"styleAttributes":{},
			"toNode":"fb1d19e43ebc636b",
			"toSide":"left"
		},
		{
			"fromNode":"fb1d19e43ebc636b",
			"fromSide":"right",
			"id":"c8ab2f4e0628b062",
			"label":"응집도가 높으면\n왜 좋을까?",
			"styleAttributes":{},
			"toNode":"0c2927801f4f4751",
			"toSide":"left"
		},
		{
			"fromNode":"0c2927801f4f4751",
			"fromSide":"bottom",
			"id":"c6d68838540b3a6b",
			"label":"응집도가 높아지면 따라오는 다른 점은?",
			"styleAttributes":{},
			"toNode":"3a9378bbcc14dbc4",
			"toSide":"top"
		},
		{
			"fromNode":"3a9378bbcc14dbc4",
			"fromSide":"left",
			"id":"480467cc866adfce",
			"label":"결합도란?",
			"styleAttributes":{},
			"toNode":"c36fdd9ffd06b558",
			"toSide":"right"
		},
		{
			"fromNode":"c36fdd9ffd06b558",
			"fromSide":"bottom",
			"id":"579658d206583e35",
			"label":"듣다보니 의존성이랑 비슷한데?",
			"styleAttributes":{},
			"toNode":"711adf6463490023",
			"toSide":"top"
		},
		{
			"fromNode":"711adf6463490023",
			"fromSide":"right",
			"id":"17c411e249c8fb8a",
			"label":"의존성이란?",
			"styleAttributes":{},
			"toNode":"352f09b4b906fe8b",
			"toSide":"left"
		},
		{
			"fromNode":"352f09b4b906fe8b",
			"fromSide":"bottom",
			"id":"bba6c5379d84aeb1",
			"label":"객체지향 설계란?",
			"styleAttributes":{},
			"toNode":"8e1e3d9eee93d86a",
			"toSide":"top"
		},
		{
			"fromNode":"10b3da348a2c9317",
			"fromSide":"right",
			"id":"0f1f6c60f4c817d8",
			"styleAttributes":{},
			"toNode":"817de4a477b3ee57",
			"toSide":"left"
		},
		{
			"fromNode":"d7089d5a4c373808",
			"fromSide":"bottom",
			"id":"ab3c53ac2e8e44c1",
			"label":"책임, 역할, 협력?",
			"styleAttributes":{},
			"toNode":"7eae115fb3ce5339",
			"toSide":"top"
		},
		{
			"fromNode":"7eae115fb3ce5339",
			"fromSide":"right",
			"id":"67151aaa6277a5e5",
			"label":"메시지?",
			"styleAttributes":{},
			"toNode":"4aa108a263a68ecb",
			"toSide":"left"
		},
		{
			"fromNode":"4aa108a263a68ecb",
			"fromSide":"right",
			"id":"83cda15a3ad06bb4",
			"label":"메시지의 특징은?",
			"styleAttributes":{},
			"toNode":"34cf0e0839b7f7e1",
			"toSide":"left"
		},
		{
			"fromNode":"34cf0e0839b7f7e1",
			"fromSide":"bottom",
			"id":"e63e596e1cb0ec9c",
			"label":"캡슐화란?",
			"styleAttributes":{},
			"toNode":"cff50e7ca75380ed",
			"toSide":"top"
		},
		{
			"fromNode":"cff50e7ca75380ed",
			"fromSide":"bottom",
			"id":"b526b3f86440f245",
			"label":"그럼 무엇을 캡슐화해야 하는가?",
			"styleAttributes":{},
			"toNode":"7081abee64d59c64",
			"toSide":"top"
		},
		{
			"fromNode":"7081abee64d59c64",
			"fromSide":"right",
			"id":"8d7eb96e358d4302",
			"label":"캡슐화하면 \n어떤 장점이 있지?",
			"styleAttributes":{},
			"toNode":"a25afc7fec7f40bd",
			"toSide":"left"
		},
		{
			"fromNode":"a25afc7fec7f40bd",
			"fromSide":"bottom",
			"id":"d4626aaf8a3b20d2",
			"label":"그렇다면 한 메시지에 대해\n다르게 답할 수도 있겠다!",
			"styleAttributes":{},
			"toNode":"7894d5db80b4f0f1",
			"toSide":"top"
		},
		{
			"fromNode":"7894d5db80b4f0f1",
			"fromSide":"left",
			"id":"bdefa67d3b3fff01",
			"label":"다형성의 장점도\n포함하는 것 같다.",
			"styleAttributes":{},
			"toNode":"a25afc7fec7f40bd",
			"toSide":"left"
		},
		{
			"fromNode":"a25afc7fec7f40bd",
			"fromSide":"right",
			"id":"11495dbd33fd0ed4",
			"label":"객체지향 설계란?",
			"styleAttributes":{},
			"toNode":"d95abd9ac84a795a",
			"toSide":"left"
		},
		{
			"fromNode":"7894d5db80b4f0f1",
			"fromSide":"bottom",
			"id":"609de970c5387ba0",
			"label":"그렇다면 다형성으로\n 확장성을 고려할 수 있겠다!",
			"styleAttributes":{},
			"toNode":"50d6822fa8656aba",
			"toSide":"right"
		},
		{
			"fromNode":"50d6822fa8656aba",
			"fromSide":"bottom",
			"id":"cdfcebc2cb7cd767",
			"label":"메시지를 정의해둔다 = 인터페이스?",
			"styleAttributes":{},
			"toNode":"87cb6b2ce5536ab6",
			"toSide":"top"
		},
		{
			"fromNode":"87cb6b2ce5536ab6",
			"fromSide":"right",
			"id":"a95459ff956e6048",
			"styleAttributes":{},
			"toNode":"f6c8705e3dff42a0",
			"toSide":"left"
		},
		{
			"fromNode":"87cb6b2ce5536ab6",
			"fromSide":"left",
			"id":"e308d8c93db67823",
			"styleAttributes":{},
			"toNode":"da394d110b4b8858",
			"toSide":"right"
		},
		{
			"fromNode":"7081abee64d59c64",
			"fromSide":"left",
			"id":"0731e534b2f5020f",
			"label":"밖에서 못건드린다면\n일어나는 일은?",
			"styleAttributes":{},
			"toNode":"44673bec8e68072f",
			"toSide":"right"
		},
		{
			"fromNode":"87cb6b2ce5536ab6",
			"fromSide":"bottom",
			"id":"fc8ac96c5c007724",
			"label":"인터페이스 vs 추상 클래스",
			"styleAttributes":{},
			"toNode":"77f4eb4f769979aa",
			"toSide":"top"
		},
		{
			"fromNode":"77f4eb4f769979aa",
			"fromSide":"bottom",
			"id":"16aa3e9cec862aac",
			"label":"어떨 때 인터페이스를 쓰고,\n어떨 때 추상 클래스를 쓸까?",
			"styleAttributes":{},
			"toNode":"dbb53847177ad561",
			"toSide":"top"
		},
		{
			"fromNode":"dbb53847177ad561",
			"fromSide":"right",
			"id":"f81bf99d49d6276d",
			"label":"타입 계층?",
			"styleAttributes":{},
			"toNode":"4411d589aa6f40fe",
			"toSide":"left"
		},
		{
			"fromNode":"4411d589aa6f40fe",
			"fromSide":"right",
			"id":"1a0c3933625a887b",
			"label":"그렇다면\n코드 재사용의 목적은?",
			"styleAttributes":{},
			"toNode":"138a67663a667de5",
			"toSide":"left"
		},
		{
			"fromNode":"4411d589aa6f40fe",
			"fromSide":"bottom",
			"id":"25be28867492befc",
			"label":"상속의 단점은?",
			"styleAttributes":{},
			"toNode":"43074cd131d11d98",
			"toSide":"top"
		},
		{
			"fromNode":"4411d589aa6f40fe",
			"fromSide":"top",
			"id":"4782a24708d1cec6",
			"label":"상속의 장점은?",
			"styleAttributes":{},
			"toNode":"ae348c49bd494776",
			"toSide":"bottom"
		},
		{
			"fromNode":"ae348c49bd494776",
			"fromSide":"right",
			"id":"d5bd824202cfebb2",
			"label":"추상화란?",
			"styleAttributes":{},
			"toNode":"e1db160e8b009ea7",
			"toSide":"left"
		},
		{
			"fromNode":"e1db160e8b009ea7",
			"fromSide":"top",
			"id":"8d0fd3f902b2a251",
			"label":"추상화의 장점은?",
			"styleAttributes":{},
			"toNode":"d5e5d0b55b348f31",
			"toSide":"bottom"
		},
		{
			"fromNode":"d5e5d0b55b348f31",
			"fromSide":"left",
			"id":"fea257ca8efed66d",
			"label":"다시 이 말로 이어질 수 있다.",
			"styleAttributes":{},
			"toNode":"f6c8705e3dff42a0",
			"toSide":"top"
		},
		{
			"fromNode":"d5e5d0b55b348f31",
			"fromSide":"right",
			"id":"0a7ee9113188cba1",
			"label":"이어서 말하자면..",
			"styleAttributes":{},
			"toNode":"35be4973b2668eec",
			"toSide":"left"
		},
		{
			"fromNode":"35be4973b2668eec",
			"fromSide":"top",
			"id":"0ff2d6c03e671730",
			"label":"객체지향 설계란?",
			"styleAttributes":{},
			"toNode":"52a065046f12b3f0",
			"toSide":"bottom"
		},
		{
			"fromNode":"138a67663a667de5",
			"fromSide":"right",
			"id":"22fdea778933d6d6",
			"label":"composition?",
			"styleAttributes":{},
			"toNode":"e3a09a874d2b8c87",
			"toSide":"left"
		},
		{
			"fromNode":"44673bec8e68072f",
			"fromSide":"left",
			"id":"78119a2374366b52",
			"label":"객체지향 설계란?",
			"styleAttributes":{},
			"toNode":"147a33f13360e431",
			"toSide":"right"
		},
		{
			"fromNode":"e3a09a874d2b8c87",
			"fromSide":"bottom",
			"id":"de810d00b327b6c4",
			"label":"composition의 장점은?",
			"styleAttributes":{},
			"toNode":"ae5dd13c07e28a19",
			"toSide":"right"
		},
		{
			"fromNode":"ae5dd13c07e28a19",
			"fromSide":"left",
			"id":"eb94404775b4e0be",
			"label":"참고: 상속의 단점",
			"styleAttributes":{},
			"toNode":"43074cd131d11d98",
			"toSide":"right"
		}
	],
	"metadata":{},
	"nodes":[
		{
			"height":60,
			"id":"f7c860d7863b89a9",
			"styleAttributes":{},
			"text":"유지보수",
			"type":"text",
			"width":260,
			"x":-120,
			"y":40
		},
		{
			"height":80,
			"id":"6bc890568fcbd4fd",
			"styleAttributes":{},
			"text":"변경에 용이한 설계가 필요하다.",
			"type":"text",
			"width":260,
			"x":-120,
			"y":220
		},
		{
			"height":240,
			"id":"10b3da348a2c9317",
			"styleAttributes":{},
			"text":"변경이 용이하다는 것은 어떠한 요구사항의 변경이 일어났을 때, 해당 요구사항을 반영한다고 해서 다른 기능들에 대한 사이드 이펙트가 발생해서는 안된다. (= 요구사항을 반영할 때 다른 기능들을 수정해서는 안된다.)",
			"type":"text",
			"width":260,
			"x":-120,
			"y":380
		},
		{
			"height":100,
			"id":"ba6c3ff1670db01f",
			"styleAttributes":{},
			"text":"각 객체는 변경의 이유를 하나만 가져야 한다.",
			"type":"text",
			"width":260,
			"x":-120,
			"y":720
		},
		{
			"color":"4",
			"height":100,
			"id":"ce404c0b3cfdd5a3",
			"styleAttributes":{},
			"text":"각 객체는 하나의 책임만 담당해야 한다. **= SRP(단일 책임 원칙)**",
			"type":"text",
			"width":260,
			"x":-120,
			"y":920
		},
		{
			"height":60,
			"id":"09748f6b032b8b1e",
			"styleAttributes":{},
			"text":"**응집도**가 높은 객체",
			"type":"text",
			"width":260,
			"x":380,
			"y":940
		},
		{
			"height":120,
			"id":"fb1d19e43ebc636b",
			"styleAttributes":{},
			"text":"어떠한 변경이 일어날 때, 클래스 내부가 한꺼번에 변경되는 비율. 즉 내부 요소들이 서로 연관되어있는 정도.",
			"type":"text",
			"width":260,
			"x":820,
			"y":910
		},
		{
			"height":150,
			"id":"0c2927801f4f4751",
			"styleAttributes":{},
			"text":"요구사항의 변경에 모든 요소가 한꺼번에 변경된다면, 전부 하나의 책임을 담당하고 있다고 생각할 수 있기 때문이다.",
			"type":"text",
			"width":260,
			"x":1300,
			"y":895
		},
		{
			"height":60,
			"id":"3a9378bbcc14dbc4",
			"styleAttributes":{},
			"text":"**결합도**가 낮아진다.",
			"type":"text",
			"width":260,
			"x":1300,
			"y":1160
		},
		{
			"height":180,
			"id":"c36fdd9ffd06b558",
			"styleAttributes":{},
			"text":"두 객체가 결합되어 있는 정도. 서로가 얼마나 독립적이냐를 판단하는 정도. 즉 한 객체가 바뀔 때 다른 객체도 바뀌어야 한다면 결합도가 높다고 생각할 수 있을 것 같다.",
			"type":"text",
			"width":260,
			"x":820,
			"y":1100
		},
		{
			"height":60,
			"id":"711adf6463490023",
			"styleAttributes":{},
			"text":"결합도와 의존성은 서로 밀접한 연관이 있다고 생각한다. ",
			"type":"text",
			"width":260,
			"x":820,
			"y":1360
		},
		{
			"color":"4",
			"height":122,
			"id":"817de4a477b3ee57",
			"styleAttributes":{},
			"text":"다시 말해, 변경에 열려있어야 하고 수정에 닫혀 있어야 한다.  **= OCP(개방 폐쇄 원칙)**",
			"type":"text",
			"width":300,
			"x":280,
			"y":439
		},
		{
			"height":60,
			"id":"d7089d5a4c373808",
			"styleAttributes":{},
			"text":"단일 책임 원칙에서의 책임은 역할에 더 가깝다고 생각한다.",
			"type":"text",
			"width":260,
			"x":-660,
			"y":940
		},
		{
			"height":280,
			"id":"7eae115fb3ce5339",
			"styleAttributes":{},
			"text":"**책임**: 가장 작은 단위. 객체가 할 수 있는 가장 작은 단위의 행동이라고 생각한다.\n\n**역할**: 책임들의 집합\n\n**협력**: 메시지를 통해 서로 두 객체가 각자의 책임을 수행하기 위해 하는 행동",
			"type":"text",
			"width":260,
			"x":-660,
			"y":1140
		},
		{
			"color":"5",
			"height":100,
			"id":"8e1e3d9eee93d86a",
			"styleAttributes":{},
			"text":"응집도가 높고, 결합도가 낮으면서 의존도가 낮은 객체를 설계하는 것",
			"type":"text",
			"width":260,
			"x":1320,
			"y":1620
		},
		{
			"height":180,
			"id":"352f09b4b906fe8b",
			"styleAttributes":{},
			"text":"A가 B에 의존한다는 뜻은, B가 바뀐다면 A도 바뀐다는 것이다. 의존성이 낮아지면, 한 객체를 변경할 때의 사이드 이펙트가 낮아지므로 변경에 용이하다.",
			"type":"text",
			"width":260,
			"x":1320,
			"y":1300
		},
		{
			"color":"6",
			"height":60,
			"id":"8396d4281e45d6a3",
			"styleAttributes":{},
			"text":"객체지향",
			"type":"text",
			"width":260,
			"x":-120,
			"y":-120
		},
		{
			"height":100,
			"id":"4aa108a263a68ecb",
			"styleAttributes":{},
			"text":"각 객체들은 **메시지**를 이용해 서로 필요한 정보를 주고받는다. ",
			"type":"text",
			"width":260,
			"x":-280,
			"y":1230
		},
		{
			"height":250,
			"id":"34cf0e0839b7f7e1",
			"styleAttributes":{},
			"text":"메시지는 메서드의 **시그니처**로 나타낼 수 있다. 시그니처로만 소통할 수 있다는 것은, **객체가 무엇을 하는지는 알지만 어떻게 수행하는지는 모른다**는 뜻이다. 즉, 메시지로만 소통하면 **캡슐화**를 지킬 수 있다.",
			"type":"text",
			"width":260,
			"x":180,
			"y":1155
		},
		{
			"height":120,
			"id":"cff50e7ca75380ed",
			"styleAttributes":{},
			"text":"숨기는 것. 외부에서 접근할 수도 없게 하고, 알 수도 없게 하는 것.",
			"type":"text",
			"width":260,
			"x":180,
			"y":1500
		},
		{
			"height":239,
			"id":"ae348c49bd494776",
			"styleAttributes":{},
			"text":"다형성/추상화\n상속의 장점은 크게 다형성과 추상화가 있을 것 같다.\n\n+ **다형성**\n상속은 같은 시그니처를 사용하기에 다형성을 만족시킬 수 있다.\n\n+ **추상화**\n상속의 제일 큰 장점은 타입 계층으로 추상화를 어디까지 할 것인지 정할 수 있다는 점이라고 생각한다.",
			"type":"text",
			"width":580,
			"x":220,
			"y":2611
		},
		{
			"color":"4",
			"height":520,
			"id":"4411d589aa6f40fe",
			"styleAttributes":{},
			"text":"인터페이스는 메시지(행동, 책임)에 대한 명세서를 미리 작성해두는 느낌이고, 같은 메시지를 받는 객체들이 implements로 구현하는 느낌이다.\n\n일반적인 클래스의 상속에서의 목적은 **타입 계층의 구축**이라고 생각한다. 또한 상속은 위아래의 개념이 아니라, **기능의 확장** 개념에 가깝다고 생각한다. (실제로 자바에서도 extends 키워드를 쓴다.)\n\n예를 들자면, 장기에서 기물(piece)이 있는데 정의된 경로로 움직일 수 있는 일반적인 기물은 normalPiece로 piece에서 '경로에 따라 움직일 수 있는 기능'이 확장된 객체이다. 여기서 만약 궁성 밖으로 나갈 수 없다는 조건이 추가된다면, 해당 조건을 확장시킨 palacePiece로 타입별로 계층을 나눠볼 수있다는 뜻이다.\n\n여기서 horse(마), elephant(상)과 같은 구체화된 객체는 역시 piece(기물)로 불릴 수 있다.(마는 기물이다. 상은 기물이다.)이렇게 **하위 객체가 상위 객체로 간주**될 수 있는 상황이 있을 때 타입 계층을 구축하는 상속을 사용하는 것이고, 이 때 **LSP(리스코프 치환 원칙)**을 만족한다고 할 수 있다.\n\n정리하자면, 행동의 재정의가 주된 목적이면 인터페이스, 타입 계층 구축이 목적이면 상속을 사용할 것 같다.\n\n\n",
			"type":"text",
			"width":540,
			"x":240,
			"y":2980
		},
		{
			"height":220,
			"id":"e1db160e8b009ea7",
			"styleAttributes":{},
			"text":"추상화는 복잡도를 줄이는 방법이다. 상속에서 사용하는 것처럼 '어디까지 일반화를 시킬지'에 따라 추상화 계층을 만들 수 있다.",
			"type":"text",
			"width":260,
			"x":980,
			"y":2621
		},
		{
			"color":"4",
			"height":253,
			"id":"50d6822fa8656aba",
			"styleAttributes":{},
			"text":"메시지만 정의해둔다면, 서로 다른 구현체들을 만들 수 있을 것 같다. 다른 알고리즘을 사용할 때 이미 있던 구현체들을 건들지 않고(=수정에 막혀있고) 새로운 구현체를 만들 수 있으니(= 변경에 열려 있다) **OCP**를 만족한다.",
			"type":"text",
			"width":260,
			"x":-250,
			"y":2034
		},
		{
			"color":"4",
			"height":225,
			"id":"da394d110b4b8858",
			"styleAttributes":{},
			"text":"객체간의 역할을 잘 나누기 위해서는, 각 인터페이스마다 최소한의 메세지만 남겨서 역할을 최소화해야한다.\n= **인터페이스 최소주의 원칙 ->  ISP(인터페이스 분리 원칙)**",
			"type":"text",
			"width":280,
			"x":-600,
			"y":2409
		},
		{
			"height":180,
			"id":"87cb6b2ce5536ab6",
			"styleAttributes":{},
			"text":"인터페이스로 메시지 목록을 미리 정의해 둘 수 있다. 즉, 객체 간의 협력 관계를 인터페이스를 이용해 정의할 수 있다.",
			"type":"text",
			"width":260,
			"x":-250,
			"y":2431
		},
		{
			"height":160,
			"id":"44673bec8e68072f",
			"styleAttributes":{},
			"text":"객체는 메시지를 받고, 모든 행동을 스스로 정해서 책임을 수행한 후, 알맞은 응답을 보낸다. 즉, 객체가 **자율성**을 가지게 된다.",
			"type":"text",
			"width":260,
			"x":-380,
			"y":1780
		},
		{
			"height":329,
			"id":"77f4eb4f769979aa",
			"styleAttributes":{},
			"text":"**인터페이스와 추상 클래스** 모두 메시지를 정의해둔다는 점은 같지만, 다른 점도 있다고 생각한다.\n\n1. 인터페이스에는 상태가 들어갈 수 없지만, 추상 클래스는 상태가 있을 수 있다.\n2. 인터페이스의 상속과 클래스의 상속이라는 점에서 다르다. 인터페이스는 다중 상속이 가능하지만, 클래스 상속은 불가능하다.\n3. 둘의 목적이 다르다.",
			"type":"text",
			"width":370,
			"x":-305,
			"y":2700
		},
		{
			"height":280,
			"id":"7081abee64d59c64",
			"styleAttributes":{},
			"text":"어떻게 수행하는지를 몰라야 한다고 했는데, 그렇다면 시그니처만 밖에서 알아야 하고(협력을 해야 하니), 구체적인 구현을 몰라야 한다고 생각한다. 즉, **구현을 캡슐화**한다. 다시 말하면 **변경 가능한 부분은 모두 캡슐화**해야 한다.",
			"type":"text",
			"width":260,
			"x":180,
			"y":1720
		},
		{
			"height":225,
			"id":"a25afc7fec7f40bd",
			"styleAttributes":{},
			"text":"내가 어떻게 수행하는지를 다른 객체에게 보여줄 필요가 없다. 구체적인 구현 부분이 바뀌어도 밖에서는 인지할 수 없으니, **변경이 용이**해진다. 즉 요구사항의 변화에 다형성으로 대응할 수 있다.",
			"type":"text",
			"width":260,
			"x":720,
			"y":1720
		},
		{
			"color":"5",
			"height":60,
			"id":"d95abd9ac84a795a",
			"styleAttributes":{},
			"text":"변하는 부분을 캡슐화하고, 다형성을 적용하는 설계",
			"type":"text",
			"width":260,
			"x":1240,
			"y":1803
		},
		{
			"height":160,
			"id":"7894d5db80b4f0f1",
			"styleAttributes":{},
			"text":"그렇다. **같은 메시지에 대해 서로 다르게 답할 수 있는 능력**을 **다형성**이라고 생각한다. 캡슐화를 하면 다형성이 적용될 수 있다.",
			"type":"text",
			"width":260,
			"x":720,
			"y":2080
		},
		{
			"color":"5",
			"height":111,
			"id":"f6c8705e3dff42a0",
			"styleAttributes":{},
			"text":"인터페이스에 대해 프로그래밍하기!\n= 상태보다 행동을 먼저 고려하는 설계를 하기!",
			"type":"text",
			"width":300,
			"x":120,
			"y":2466
		},
		{
			"height":200,
			"id":"d5e5d0b55b348f31",
			"styleAttributes":{},
			"text":"추상화를 할수록 '이해하기 쉬워진다'가 장점이라고 생각한다. 복잡도가 줄어들기에 **요구사항에 대한 정책을 상위 수준에서 서술**할 수 있고, 그럴수록 이해하기 쉬워지는 것이다. 이는 즉 실제 구현보다 객체 간 협력에 집중하게 되는 효과도 생기므로 메시지만을 이용하여 협력하자는 객체지향의 설계 원칙과도 잘 어울린다.",
			"type":"text",
			"width":460,
			"x":980,
			"y":2300
		},
		{
			"color":"4",
			"height":260,
			"id":"35be4973b2668eec",
			"styleAttributes":{},
			"text":"상위 수준에서 협력한다면, 내부 구현을 신경쓰지 않아도 된다. 만약 구체적인 내부 구현에 따라 프로그램의 전체 흐름이 바뀐다면, 분명 잘못된 설계일 것이다. 즉, 상위 모듈이 하위 모듈에 의존하게 된다면 변경에 유연하지 못한 설계가 된다\n\n= 상위 모듈이 하위 모듈에 의존하는 것이 아니라, 하위 모듈이 상위 모듈에 의존해야 한다. **나보다 변하기 쉬운 것에 의존하지 말자** 라는 말이 **DIP(의존성 역전 원칙)**의 의미라고 생각한다.",
			"type":"text",
			"width":460,
			"x":1660,
			"y":2270
		},
		{
			"color":"5",
			"height":60,
			"id":"52a065046f12b3f0",
			"styleAttributes":{},
			"text":"추상화에 의존하는 설계",
			"type":"text",
			"width":260,
			"x":1760,
			"y":2060
		},
		{
			"height":320,
			"id":"43074cd131d11d98",
			"styleAttributes":{},
			"text":"1. 결합도가 너무 강하다. = 코드의 변경에 대해 유연하지 않다.\n2. 상속된 객체끼리는 상태를 공유할 수 있다. 즉, 캡슐화가 깨진다.\n\n그래서 상속은 정말 필요할 때에만 사용하는 것이 맞다고 생각한다.",
			"type":"text",
			"width":260,
			"x":380,
			"y":3600
		},
		{
			"height":100,
			"id":"dbb53847177ad561",
			"styleAttributes":{},
			"text":"타입 계층을 나누어야 하는가 아닌가에 따라 갈릴 것 같다.",
			"type":"text",
			"width":260,
			"x":-250,
			"y":3190
		},
		{
			"height":188,
			"id":"138a67663a667de5",
			"styleAttributes":{},
			"text":"상속은 코드 재사용의 용도로 사용하면 안된다고 생각한다. **코드를 재사용하는것이 주된 목적이면 composition(조합, 합성)**을 쓰는 것이 더 좋을 것 같다.",
			"type":"text",
			"width":260,
			"x":1060,
			"y":3152
		},
		{
			"height":208,
			"id":"e3a09a874d2b8c87",
			"styleAttributes":{},
			"text":"흔히 상속을 is-A관계라고 하고, composition을 has-A관계라고 한다. 객체가 다른 객체를 필드로 가지는 관계를 has-A라고 하고, 이 방식이 코드 재사용에 더 효과적이라고 생각한다.",
			"type":"text",
			"width":260,
			"x":1500,
			"y":3142
		},
		{
			"color":"5",
			"height":60,
			"id":"147a33f13360e431",
			"styleAttributes":{},
			"text":"객체가 자율성을 가지는 설계",
			"type":"text",
			"width":260,
			"x":-860,
			"y":1830
		},
		{
			"height":180,
			"id":"ae5dd13c07e28a19",
			"styleAttributes":{},
			"text":"필드로 인스턴스를 가지고 있기 때문에, 의존하는 인스턴스 교체가 쉬워 **설계를 유연**하게 만든다. 즉, 상속의 단점을 모두 커버할 수 있다.",
			"type":"text",
			"width":260,
			"x":1060,
			"y":3410
		}
	]
}