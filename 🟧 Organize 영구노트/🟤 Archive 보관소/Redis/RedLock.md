#Redis 

## 분산락(Distributed Lock)의 필요성
기본적으로 레디스(Redis)는 싱글 스레드로 동작하기 때문에, 단일 레디스 노드를 구축해 사용해도 동시성 문제가 발생하지 않는다.

따라서 리소스에 대해 값을 설정하여, **값이 설정된 경우에는 다른 리소스의 접근을 차단**할 수 있다. 이를 잠금이라고 표현할 것이며, 이를 위해 다음과 같은 명령을 사용할 수 있다.

```bash
// key, value를 저장하는데 NotExists일 경우에만 저장하고, 30초(30000ms) 동안 유지해줘
SET key value NX PX 30000
```

잠금 해제는 다음과 같이 할 수 있다.
```bash
DEL key
```

하지만 이렇게 DEL 연산을 검증없이 허용하면 잠금을 획득하지도 않은 클라이언트가 잠금을 해제할 수 있으므로 안전하지 않다. 따라서 다음의 조건을 만족하는 경우에만 잠금을 해제할 수 있도록 해야 한다.

> [!summary]+ 
> 1. 키가 존재하고
> 2. 키에 저장된 값이 클라이언트의 값과 일치하는 경우

하지만 이러한 방식으로 구축된 단일 레디스 노드는 단일 장애 지점(SPOF, Single Point Of Failure)이 될 수 있다. 민감한 리소스가 아니라면 단일 노드로도 충분하지만, 그렇지 않다면 보완이 필요하다.

이를 위해 Master-Slave 복제(replication) 모드로 레디스 서버를 구축하기도 하지만 레디스의 복제는 비동기식이기 때문에 상황에 따라 경쟁 상태(race condition)가 발생할 수 있다.

## 분산 락
> [!note]+ 
> 경쟁 상황(Race Condition) 이 발생할때, 하나의 공유자원에 접근할때 데이터에 결함이 발생하지 않도록 원자성(atomic) 을 보장하는 기법

> [!faq]+ race condition
> 동시에 여러개의 프로세스가 하나의 공유자원(데이터)에 대해 접근하여 Read, Write 연산을 진행하면서 발생하는 경쟁 상황

## 레드락(RedLock)
이러한 문제들을 보완하기 위해 레디스는 분산락 알고리즘의 구현으로 레드락(Redlock) 알고리즘을 제안했다. **레드락은 N개의 단일 레디스 노드들을 이용하여, Quorum 이상의 노드에서 잠금을 획득하면 분산락을 획득한 것으로 판단**한다.
![[분산락.png]]