#TrubleSooting #Project 

우리는 대기열을 구현하기 위해 수많은 아키텍쳐를 고려하고, 검증 과정을 거치면서 최종적으로 WebFlux + redis 조합을 사용하였다. 어떤 조합을 시도해 보았는지에 대해 정리해 보았다.

> [!summary]+ 
> 1. Redis + Redis
> 2. SQS + Redis
> 3. Redis + Lambda + Redis
> 4. Redis + Spring MVC + Redis -> Webflux + Redis

## 1. Redis + Redis
처음 생각했던 아키텍쳐는 단순히 Redis 하나를 대기열 큐로 쓰는 것이었다. 하지만, Redis 하나만을 쓰기에는 트래픽을 감당할 수가 없다고 판단하여, Redis 두개를 이어붙여서 하나는 대기열 큐, 하나는 작업 큐 이렇게 2개의 Redis를 동시에 사용해보기로 했다.

Redis 2개를 동시에 사용하려는 생각은 괜찮았지만, 대기열 큐는 [[Sorted Sets]] 자료구조를 사용하고 작업 큐는 pub-sub 방식을 사용하는데, 이 두 Redis를 연동할 수 있는 방법을 찾을 수 없었다.

그래서 2가지 방법을 생각해 보았다.
1. 대기열 큐에서 Redis 대신 SQS 사용
2. 두 Redis를 이어주는 아키텍쳐 도입

## 2. SQS + Redis
AWS에서 제공하는 SQS를 사용해 보기로 했다. SQS + Redis를 사용하는 아키텍쳐는 난이도도 그렇게 어렵지 않게 구현할 수 있었지만, 심각한 문제가 발생하였다. SQS에서 누락되는 트래픽이 많다는 점이었다. 이것은 표준 대기열과 FIFO 대기열 상관없이 모두 적용되는 문제였다. 해결 방법을 찾아보려 노력하였으나, 프로젝트 특성상 시간 제약 때문에 어쩔 수 없이 SQS는 포기해야 했다.

## 3. Redis + Lambda + Redis
Redis 사이를 Lambda를 이용해서 엮는 방법도 시도해 보았지만, 2번과 마찬가지로 누락되는 트래픽이 생기는 것을 확인하였다. Lambda로 들어가는 것까지는 거의 100% 완료하였지만, 작업 큐에서 Lambda의 패킷들을 가져오는 과정에서 문제가 있었다.

## 4. Redis + Spring MVC + Redis -> Webflux + Redis
Lambda를 사용해보고, 이 방법이 괜찮다고 생각하여 우리에게 익숙한 Spring MVC로 중간 매개체를 바꾸는 것을 고려하였다. 하지만 이렇게 되니, 굳이 Redis를 하나 더 써야 할까라는 생각이 들었다. 왜냐하면 Spring 자체를 하나의 큐로 이용하는 것이 더 효율적이기 때문이었다. 하지만 일반적인 MVC는 대용량 트래픽을 받기에 부족한 점이 있었고, 이에 따라 최종적으로 Webflux + Redis 조합으로 대기열 아키텍쳐를 구성하게 되었다.
