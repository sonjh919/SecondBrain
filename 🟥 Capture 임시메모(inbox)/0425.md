발화자 1 : 라젤
발화자 2 : 밍트
발화자 3 : 헤일러
발화자 4 : 링크
발화자 5 : 머피
발화자 6 : 칼리

발화자 1 (00:10)
응, 응 메모리. 

발화자 2 (00:15)
그럼 때문에 한번 얘기를 하고 있을까요? 

발화자 1 (00:18)
그렇죠? 

발화자 2 (00:20)
메모리는 어떠한 역할을 하고 있는가 제가 정리한 도표는 메인 메모리란 실행되는 프로그램의 명령어와 데이터를 일시적으로 저장하는 공간이다 CPU가 빠르게 접근할 수 있으며 램과 룸 두 가지가 있다 이렇게 작성을 해 봤는데요? 혹시 저는 어떻게 작성하셨나요? 

발화자 1 (00:45)
저는 궁금한 게 하나가 있어요. 네 그 이게 그 램이 전원이 꺼지면 메모리 내용이 사라지기 때문에 영구적으로 보존하는 장치인 보존 기억 장치를 사용하잖아요. 근데 왜 그 얘가 더 비싼지 모르겠어요. 

발화자 1 (01:02)
램이 왜 더 비쌀까요 사라지는데? 

발화자 3 (01:09)
사라지는데 왜 비싸냐고요? 

발화자 1 (01:11)
그러니까 정보가 휘발성이잖아. 

발화자 3 (01:14)
읽는 속도가 훨씬 빨라요. 

발화자 1 (01:16)
그 그게 더 비싼 이유. 

발화자 3 (01:19)
저 프로그램 실행 중에 이제 어떻게 보면 사람이 좋은 사용자 경험을 위해서는 빠르게 반응을 해야 되잖아요. 사용자의 입력에 대해서 입출력 장치로 뭔가 마우스 클릭을 하나 키보드를 눌렀을 때 빠르게 동작을 하는 게 더 중요하기 때문에 실제 서비스를 사용을 할 때. 

발화자 1 (01:36)
그러면은 그니까 용량 용량보다는 빠르기에 따라서 더 가격 차이가 난다고 봐야 되나요? 그니까 어찌 됐든 메모리는 보조 기억 장치든 데이터를 저장하기만 하잖아요. 그게 휘발성이냐 아니면 연구성이냐에 따라 다른 거지 으흠 네 그러면은 단순히 조금씩. 

발화자 3 (01:55)
생 속도를 그렇게 빠르게 하기 위해서 더 지적 회로가 세밀하고 더 어렵게 설계돼 있어요. 그니까 회로 회로 설계 자체가 훨씬 어렵게 돼 있어요. 레이. 

발화자 4 (02:08)
맞아 옛날에 행정이라 하는 게 그렇구나. 

발화자 3 (02:11)
그래서 속 그 속도를 개선하기 위해 더 고급 직접 회로를 사용하기 때문에 더 비싼 거다. 

발화자 1 (02:18)
그래서 비싼 거다. 

발화자 3 (02:19)
진짜 현실적으로 얘기를 하자면 그쵸 그냥 데이터 단순히 저장하는 거는 이제 단순한 직접 회로가 사용되기 때문에 재료값이 싸다 비용도 비싸다. 네. 

발화자 2 (02:35)
그래서 그냥 음과 눈 차이가 있어서 표에 응. 

발화자 3 (02:44)
음 여자 정확한 그 틀어. 

발화자 4 (02:48)
펌웨어가 뭐죠? 

발화자 3 (02:50)
커메어는 그런 거예요? 공유기에 들어가는 소프트웨어가 펌웨어거든요. 그러니까 얘가 변경되지 않을 소프트웨어인데 쫌 변경되지 않을 디바이스 드라이버 디바이스를 컨트롤 할 수 있는 하드웨어와 거의 맞닿아 있는로 저 수준의 소프트웨어. 

발화자 4 (03:14)
투자한테 바뀔 일이 없는 그치 바뀔 일이 없는. 

발화자 3 (03:18)
그래서 리드 온리 메모리의 약자로 수정되지 않는. 

발화자 1 (03:22)
위조님의 머리 응 내가 이거 소개해 봐 드러워도. 

발화자 3 (03:30)
그래서 1위 기도 소프트웨어가 업데이트 될 때 내부적으로 코드가 고쳐지는 게 아니고 다 덮어써요 있던 걸 다 삭제하고 공유기 업그레이드 할 때도 음 소프트웨어를 더 받습니다. 그래서 컴퓨터 부트로더나 공유기 펌웨어가 이제 대표적인로. 

발화자 1 (03:53)
음 룸하고 램 차이 되게 열심히 공부했었는데 기억이 크기가 큰 편과 작은 편은 멀게 나올까요? 

발화자 3 (04:06)
사이즈 면의 용량 말하는 거죠 용량이요 롬에 비해선 큰 편이다 상대적으로. 

발화자 2 (04:17)
혹시 궁금증 어떤 걸로 배우셨습니까? 

발화자 5 (04:20)
어 이번에도 궁금증이 있긴 한데 뭐 생각해 보니 어차피 시스템 버스 안에 다 연결돼 있잖아요. 그 하늘이 있었거든 보도시영 장선수 2억 장수 그래. 가지고 보조 기억 장치에서 바로 땡겨버리면 되지 않나 라는 고민을 했었는데 어 고속도랑 가격 때문에 타협한 구조일까 아니면 아예 붉은 여기일까 생각해봐 그것도 생각해 봤는데 뭔가 아예 불가한 내용이 아닌 거 같은 게 결국에는 운영체제가 가상 메모리를 지원하고 있으니까 뭐 아예 불가능한 여행이 아닌 것 같고 그냥 가성비를 생각했을 때 좋지 않은 노조인 것 같아서 현재의 폰 노이방 쪽에서 유지하는 게 아닌가 라는 생각을 했습니다. 

발화자 4 (05:01)
가상 메모리는 어 어디서 땡겨서 쓰는지 알아? 

발화자 5 (05:07)
파는 리스크 그냥 두 메모리 그니까 고전 메모리를 메모리처럼 사용할 수 있게 해주는 건데 어 애초에 공고부터 내가 알기로는 그냥 쓰지 말라고 나와야죠. 웬만하면 이거를 쓰지 말고 약간 음 어디서 쓰냐면은 그 이지 투에서 약간 기본적으로 쓰는 느낌 왜냐면은 꺼지면 안 되니까 그냥 보여드리지 않죠. 

발화자 4 (05:32)
그래서 그 섞어 두는 거 얘기를 하는 거예. 

발화자 5 (05:34)
뭔가 어 수학 메모리 부는 게 비슷한 거 같 그래서 그냥 꺼지면 안 되는 거니까 약간 주어져 있지도 않고 거기까지는 그래서 그런 걸로만 알고 있어. 

발화자 4 (05:45)
어 근데 그 거기서 내가 얘를 뭐 메모리로 쓰겠어라고 지정을 한다고 그게 진짜 메모리처럼 속도가 빨라지는 그런 게 그게 가능한가? 

발화자 5 (05:54)
어 내부적인 기사 나 잘 모르는데 그 엄청 큰 하드디스크를 소모해가지고 응 쪼그만 이렇게 나쁜데 그렇습니다. 되게 비효율적이죠 기억이. 

발화자 3 (06:05)
그치 근데 메모리가 비싸니까 응 하드웨어를 음 하드웨어를 논리적으로 이거 램처럼 사용을 하려고 하는 거지? 

발화자 5 (06:17)
운영체들이랑 되시는 걸로. 

발화자 3 (06:18)
그니까 메모리 메모리는 내가 백 뭐 16기가밖에 없지만 하드디스크에 있는 백 기가까지 내가 논리적으로 주메모리처럼 할당을 해서 사용하는 것처럼 쓰는 거야. 

발화자 4 (06:29)
음 

발화자 3 (06:30)
계속 바꿔가면서 위치를 네 필요 없 당장 필요 없는 거는 하드웨어로 다시 돌리고 하드웨어에서 필요한 것만 다시 메모리로 끌어오면서 근데 이제 프로그램 내에서는 이제 논리적인 이제 용량을 관리를 할 때는 116기가처럼 쓰는 거지 음 어플리케이션 레벨에서. 

발화자 4 (06:53)
하 되게 어려운 기술이네. 

발화자 3 (06:55)
이제 어려울 수 있는데 수학 비용이 되게 커. 

발화자 4 (06:59)
진짜 커 보인다. 말만 들어 놓고요. 

발화자 1 (07:03)
보조 기억 장치는 어떤 역할을 하고 있는가? 

발화자 4 (07:07)
메모리 메모리 하나 더 말하고 싶은 거 있어요? 네 그 여기서 이제 뭐 테일러가 한번 말했던 거긴 한데 랜덤 메모리 액세스 랜덤 엑세스 메모리인데 왜 랜덤인가 어 왜 랜덤 미라는 말이 왜 붙었는가에 대해서 혹시 아시는 분 있나요? 

발화자 2 (07:29)
다낭. 

발화자 1 (07:31)
랜덤 몇 명 있었어? 

발화자 3 (07:33)
음 어? 

발화자 4 (07:35)
어 얘기를 하자면 이 무작위라는 게 어 저장되어 있는 위치가 어디든지 상관없이 접근하는데 시간이 동일하게 걸린다라는 의미에서 랜덤이 붙었다라고 응 그래서 이거랑 이제 같이 나오는 게 순차 접근 방식이라고 했는데 걔는 저장이 얘가 어디에 돼 있냐에 따라서 이 그거를 차례대로 훑기 때문에 그 정보가 저장된 곳에 따라서 그거를 읽는 시간이 달라 음 근데 이제 랜덤 이제 램 같은 경우는 식 찾는 시간이랑 그 저장된 위치랑 그게 무한하다 라는 거를 반영을 해서 이제 랜덤이라는 말을 쓴다 라고 합니다. 

발화자 1 (08:22)
한 줄 요약하자면? 

발화자 2 (08:23)
좋아요 가설 한 줄 요약하자면. 

발화자 4 (08:26)
어 맞아 순서. 

발화자 3 (08:28)
음 그치 저 랜덤의 의미를 잘못 알고 있는 사람이 많아서. 

발화자 1 (08:32)
저장된 순서가 아닌 이미애 순서는 엑소시. 

발화자 2 (08:36)
가끔 생각을 해봐요. 

발화자 1 (08:38)
그러니까 어디서 접근하든 시간이 갔다는 건가? 

발화자 3 (08:40)
음 어느 메모리 주소에 접근을 하든 접근 시간이 똑같다. 

발화자 1 (08:44)
굉장히 위에 임의의 순서로. 

발화자 4 (08:46)
저장되어 있는 위치에 상관없이 적분 속도가 똑같고. 

발화자 1 (08:50)
음 

발화자 3 (08:51)
메모리가 16기가 까지인데 일 기 뭐 일 기가 먼저 있는 걸 데이터에 접근하는 거나 10기가 먼저 데이터에 접근을 하는 거나 똑같다는 거지 접근속도. 

발화자 1 (09:01)
아 그러면 확실히 더 비쌀만 하네. 비쌀 만해? 

발화자 2 (09:10)
다음 세 번째 질문 보조기억장치는 어떤 역할을 하고 있는가? 

발화자 1 (09:16)
영구적인 저장소이다. 

발화자 2 (09:23)
아 좀 길게 써야겠습니다. 어, 어 이거 누가 적어도와 제가 했나요? 전원이 전원이 꺼져도 데이터가 유지되는 영구적인 저장소이다. 

발화자 2 (09:35)
A씨디에스에스디 하드디스크 드라이브 등이 나 네 당신 여기서는 어떤 걸 얘기하면 좋을까요 뭐 보조기억 장치의 종류에 대해 얘기를 하는 게 좋고. 

발화자 1 (09:55)
궁금한 게 있어요. 저는 이게 영구적으로 주장을 하잖아요. 근데 어찌 됐든 그거를 저장을 해놓으면 끌어다 쓸 게 있는 거잖아요. 

발화자 1 (10:05)
네 그러면은 그거를 껐다 키면 어떻게 돼요? 그 예를 들어서 그니까 컴퓨터가 아예 꺼지는 게 아니라 그 프로그램을 껐어요 그럼 메모리에서 나가잖아요 필요가 없으니까 여기에 그 보조기억장치는 남아 있을 거 아니에요 근데 또 그걸 다시 켜요. 그러면은 그 보조 기억 장치 걸 끌어다 메모리에다 넣고 이제 메모리에다 뭐 쓰는 건지 그런 걸 잘 모르겠어요. 

발화자 1 (10:27)
그 과정을. 

발화자 5 (10:29)
그 과정은 이제 운영 체제가 해주는 걸로 알고 있습니다. 존댓말 써야 되나요? 반말 써야 되나요? 

발화자 1 (10:36)
반말 쓸까요? 

발화자 3 (10:38)
엄마가 지금 부담하네. 3만원 안 받았어. 반만 원. 

발화자 5 (10:41)
그거는 이제 나도 사실 난 보증기압 장치 하면 그것밖에 생각이 안 나긴 하는데 운영체제에서 이제 읽을 읽을 때는 굉장히 빠르게 읽을 수 있는 걸로 알고 그래서 무조건적인 동계가 되는 걸로 아는데 뭐 쓰기 자료나 아무래도 하루 쓸 때 내려보내야 되니까 시간 오래 걸리기 때문에 운영체에서 이제 버퍼를 두고 그 버퍼를 플러시안 형태로 한단 말이지 음 그래서 그 플러시 하는 것은 이제 시스템 콜로 제공을 해주고 있고 그 뭐 읽을 때는 이제 바로 읽을 수 있다. 그래서 그 0을 노린 운영체에 대한 친구가 시스템 홀로 지원을 해주고 있고 으흠 응. 

발화자 3 (11:23)
궁금한 게 해결이 됐나요? 

발화자 1 (11:25)
네 좋습니다. 

발화자 2 (11:30)
네 네 이거 뭐 이 SD SSD 이런 거를 하나하나 공부를 해야 될까요? 

발화자 3 (11:38)
어 아직은 그냥 이런 종류가 있다만 알면 될 것 같아요. 하나하나가 뭔지는 개발 저희가 소프트웨어 개발자다 보니까. 

발화자 1 (11:48)
하드웨어까지 저렇게 파면은 기계공무원 그 쫌 약간. 

발화자 3 (11:54)
네 당장은 몰라도 그게 상관없다. 앞으로도 아마 골라도 상관없을 가능성이 높다. 

발화자 2 (12:02)
음 넘어가겠습니다. 혹시 질문 뭘로 하실 질문 없었어요? 오케이 다만 네 번째 입출력 장치는 어떤 역할을 하고 있는가 컴퓨터 외부와 연결되어 데이터 교환을 담당하는 장치이다? 

발화자 2 (12:16)
키보드 마우스 모니터 등이 있다. 근데 혹시 보충할 내용이 있나요? 

발화자 1 (12:25)
응, 응 

발화자 4 (12:26)
음 보조 기억 장치도 관점에 따라서 입출력 장치로 볼 수 있다라는 말이 책에 있거든요. 

발화자 2 (12:33)
아 예 맞아요. 

발화자 4 (12:35)
그래서 그 두 개를 합쳐서 주변 장치라고도 말한다. 맞아. 

발화자 1 (12:38)
어느 정도까지. 

발화자 2 (12:42)
김민규 모집. 

발화자 1 (12:46)
그니까 외장 카드가 따지고 보면 입출력 이런 걸 수도 있다. 

발화자 3 (12:52)
응 살짝 우리 스프링 관점으로 보면 메인 메모리가 서비스라고 생각을 하고 이제 주변 장치들이 레포지털인데 이제 레포지토리가 입출력 장치인 키보드 마우스가 될 수도 있는 거고 아니면은 하드디스크 SSD 같은 보조 기억 장치가 될 수도 있는 거고 데이터를 끌어오는 소스가. 

발화자 5 (13:14)
나는 그 배웠는 일 그 입출력 장치를 우리가 어떤 식으로 대해야 되냐 이래 생각을 약간 해봤었거든요. 결국엔 이게 운영체제가 시스템고를 제공을 하는 거고 그 우리가 패션에 쓸라면은 펌웨어 같은 어떤 카메라가 아니 그 다운 받잖아 소프트웨어 그래서 그거를 어댑트 역할을 하는 그거를 개발하는 게 개발자이고이라고 알고 있어요. 결국에 내부적으로 또 이제 샘플 사당한 걸로 알고 있습니다. 

발화자 2 (13:40)
시FM4. 

발화자 3 (13:41)
버전은 어 사실 디바이스 드라이버라는 소프트웨어를 우리가 만들어야 하 그 하드웨어를 소프트웨어 레벨에서 조 그 컨트롤을 할 수 있거든요. 그 디바이스 드라이버라고 하면 아 근데 너무 진도를 빨리 나가는 거 같긴 한데 하하하하 네 디바이스 드라이머가 진짜 운영체제 커널에서 커널 수준에서 제공해 주는 그 커널 함수들를 이용을 해서 주변 장치로부터 데이터를 끌어오는 역할들을 해주거든요. 그 바로 위에 시스템 브라우저들이 있고 거나 함수들기 그래서 커다란 수와 시스템컬 함수 둘을 이어주는 게 디바이스 드라이브다 그 정도만 알고 있으면 될 것 같아요. 

발화자 1 (14:29)
운항 함수와 시스템 드라이버 아니 원래 시스템 콜. 

발화자 5 (14:35)
커널 함수가 밑에 있는 거 혹시 샘플? 

발화자 3 (14:37)
시스템 코레일 위에. 

발화자 5 (14:38)
그래서 고립이 그럼 이걸 개발하는 건가요? 

발화자 3 (14:41)
그치 그 둘 사이를 이어주는 소프트웨어를 만들 수 있어. 이제 그런 소프트웨어가 디바이스라 이거 보통. 

발화자 1 (14:51)
호호. 

발화자 4 (14:54)
재밌구만. 

발화자 3 (14:56)
지금은 네 그 이거는 근데 나중에 운영체제 공부할 때 좀 더 맞아. 

발화자 1 (15:02)
자세하게 어디서 근데 많이 들어보긴 했어. 근데 기억이 안 나 정확히 정해가 그냥 이런 게 있다는 정도만 알아두고 넘어가도 어차피 나중에 한 번 다시 공부하면서 찍게 될 테니까 시스템버스로 갈까요? 

발화자 2 (15:17)
네 

발화자 1 (15:18)
그럼 문 좀 열어줘. 

발화자 5 (15:20)
아 에어컨 안 보통. 

발화자 1 (15:21)
너무 더워. 

발화자 3 (15:24)
좀 덥네요. 

발화자 1 (15:26)
하트네오 핫 합 시스템 버스는. 

발화자 2 (15:31)
레시 시스템버스의 종류와 각 동료가 역할은 무엇인가 시스템버스의 종류는 데이터 버스 주석 코스 제어 코스로 구성된다? 데이터 버스는 데이터를 전송하는데 사용되며 좌석 코스는 메모리 주소를 전달하는데 대형 버스는 제어 신호를 전달하는 데 사용한다라고 정리를 했는데 어 버스가 중요한 이유는 무엇일까요? 

발화자 3 (16:00)
사실 버스는 하드웨어 영역이라서 그냥 데이터를 버스라는 하드웨어를 통해서 각 부분들이 그 주고받는다. 전기적 신호를 통해서 모수 부호 같은 걸로. 

발화자 4 (16:15)
일단 궁금한 게 정기적 신호라고 했잖아 인력 그니까 그 일형으로만 주고받는데 이 우리 주소 버스 데이터 제어 이렇게 남은 거는 그러니까 우리가 그냥 인식하기 편하게 위해서 그냥 붙인 건가 아니면 실제로 내부에서 달라지는 게 있는 건지. 

발화자 3 (16:33)
실제로 내부에서 그 버스를 다르게 물리적으로 분리를 해서 신호를 보내는 거지. 그러니까 회로를 만들 때도 책임을 분리를 해 놓은 거야. 우리가 소프트웨어 설계를 하듯이. 

발화자 4 (16:43)
응 잉. 

발화자 3 (16:44)
이쪽 버스는 그 역할 데이터만 전달하는 버스 이쪽 버스는 메모리 주소만 전달하는 버스. 

발화자 4 (16:51)
다 0101로 가는 것도. 

발화자 3 (16:52)
똑같은 거 그치 근데 공일공일이 진짜 일 영을 하나씩만 보내는 게 아니라 멀티플렉스라고 해서 일 형을 여러 개를 회로를 붙여놓고 한 번에 보내 그러니까 그거를 여러 개의 bit를 네 이거. 

발화자 2 (17:09)
영화 컴퓨터. 

발화자 1 (17:10)
이거는 

발화자 3 (17:11)
그치 컴퓨터 구조를 좀 더 딥하게 하면은 이 책에서는 아마 멀티플렉스 이런 개념이 안 나왔던 것 같은데. 

발화자 4 (17:18)
음 그 그 컴퓨터. 

발화자 3 (17:20)
포토 구조 전공책을 보면 나와. 

발화자 4 (17:22)
그럼 그건 공일공일이 주소인지 데이터인지 이거는 물리적인 설계에 따라서 설정이 되어 있다라는 거지 그치 그치. 

발화자 2 (17:31)
맞습니다. 

발화자 5 (17:32)
이 결론은 0101이라는 건가? 

발화자 3 (17:34)
음 역시 010일을 하드웨어를 통해서 보내주는 그냥 그런 신호를 보내주는 장치일 뿐이다. 

발화자 5 (17:40)
아 그래서 나도 이게 궁금증일 0100과 1의 신호가 아닌가라고 적었어. 근데 왔다는데. 

발화자 4 (17:46)
음 음. 

발화자 1 (17:50)
음 환기가 안 되니까 계속 아픕니다. 엄청 아프죠 

발화자 3 (17:54)
다음에는 미리 예약을 하겠습니다. 

발화자 1 (17:56)
아이 뭐라고 한 거 아니에요? 

발화자 2 (17:59)
다음 다음 질문 정보 단위란 무엇이고 어떤 종류의 정보 단위가 있는가 으흠 네 우선 정보 단위란 디지털 정보의 크기 단위이다. bit 백제는 연관이 영과 일로 구성되었고 B는 8 bit 워드는 CPU가 처리하는 기본 단위이고 T 월드는 디 월드람. 

발화자 3 (18:25)
더블 거 같은데 네. 

발화자 2 (18:26)
몰티 몰드는 32 bit가 있다. 월드는 CPU가 처리할 수 있는 bit 수에 따라 달라진다. 

발화자 1 (18:34)
어 근데 저 더블 월드는 32 m가 고정이 아니라 워드에 따라서 달라지는 거예요. 

발화자 5 (18:40)
그래서 곱하기 2. 

발화자 1 (18:42)
곱하기 이루어지는 그럼 워드는 16이랑 이가 있는 건가요? 아니 워드는 그 CPU가 한 번에 처리할 수 있는 데이터 크기이기 때문에 어떤 CPU냐에 따라 다르지 않을까. 그래서 16 16이 있을 거고 32가 있을 거고 64가 있으면. 

발화자 3 (18:59)
우선 라젤의 설명이 정확하긴 한데 일단 제 CPU 제조사에 따라서 워드의 정예가 달라서 그 워드 처리 단위는 CPU 종류마다 다른데 근데 인텔은 조금 특별해 인텔이 처음 지피유 칩을 개발을 했을 때 처음에 16 bit로 개발을 했거든 그래서 워드 단위를 16 bit로 고정을 했어 얘네들은 그래서 그 16 bit 운영 아이고 그 아키텍처 이후에 X 팔육이 이제 삼십 이 bit 기준이지 그다음에 이제 지금 X 64가 64 bit 기준이고 그렇게 계속 아키텍처가 레지스터 크기도 커지면서 처리할 수 있는 단위가 bit가 늘어났음에도 인텔은 여전히 일 월드를 16 bit로 사용을 하고 있어 왜냐하면 과거의 16 bit로 시작했을 때 만들어진 소프트웨어와 16 bit 단위 워드로 최적화돼 있어서 그걸 계속 유지하려고 그래서 인텔하고 에이아 어 암듯 이 둘만 특별히 워드를 16 bit로 고정해 놓고 쓴다. 

발화자 5 (19:59)
질문님 문자 별거 아닌 건데 왜 X팔육이란 이름을 지었었는지? 

발화자 3 (20:04)
아 박스 팔육. 

발화자 5 (20:05)
그니까 나는 맨날 헷갈려가지고 외래 수정 씨비로 하면 되는데 왜 사팔육이라고 씌워가지고 다운받기가 힘든 거. 

발화자 3 (20:13)
아, 그래. 나 이름의 유래까지는 잘 모르겠어. 

발화자 5 (20:17)
나와봐. 

발화자 4 (20:17)
궁금한 게 있습니다. 그러면은 워드의 단위가 레지스터의 용량과도요. 

발화자 3 (20:24)
공간이 있나 네 맞아요. 원래는 레지스터의 그 레 범용 레지스터 에크기에 맞춰서 워드 단위가 설정이 되는데 다른 이제. 

발화자 4 (20:37)
그러면 64 비 지금 64 bit를 쓴다는 거는 레지스터. 

발화자 3 (20:42)
에스터 크기가 범용 레지스터 크기가 64 bit 남용 레지스터 레지터도 종류가 되게 많거든 그러니까 좀 특수한 목적으로 만들어진 레지스터는 막 뭐 128 bit짜리도 있고 어 그런데 그런 거는 좀 특수목적 레지스터니까 제외하고 시티오가 가장 많이 사용하는 범용 레지스터 기준으로 워드를 정의를 한다거도. 

발화자 5 (21:09)
좋습니다. 그냥 별명이라고 하네요. 

발화자 3 (21:11)
어 ARM이 아니라 암 암드일 거야. ANDAND AMDAMD 

발화자 2 (21:20)
감사합니다. 아마도 자 혹시 더 보충할 내용이 있을까요? 

발화자 1 (21:28)
남습니다. 

발화자 2 (21:29)
없으면 넘어갈까요? 

발화자 1 (21:32)
네 맞습니다 네. 

발화자 2 (21:34)
자 이해보스가 어떤 개념인가 예제를 포함해서 설명해 주세요 이에 보수는 음수를 표현하는 방식입니다. 모든 bit를 관절시킨 후 이를 더합니다 오의 이의 보수는 네 루트를 반전시킨 후 이를 더한 111101일일입니다라고 얘기를 적었는데 사실 더 얘기할 내용이. 

발화자 3 (22:05)
그럼 그럼 이해부수를 왜 쓰게 된 거 같애요? 

발화자 4 (22:08)
사실 저 그거 물어보려고 했어요. 그러니까 왜냐하면 음수를 표현하는 방식이 그럼 맨 앞에 거를 그냥 부호 bit로 정하는 방법이 있잖아 그럼 그걸로 그냥 판별을 하면 되지 않나 왜 이해보수라는 개념이 왜 나왔지 라는 의문이 있습니다. 

발화자 3 (22:23)
아 그러면 만약에. 

발화자 5 (22:24)
어 그건 영 아낄려고 영이 두 개가 나오니까 마이너스 영 플러스 영 나오니까 한 bit라고 맡길려고 하는 거 아닌가요 생기고. 

발화자 3 (22:33)
네 바지 맨 앞에를 사인 bit로 고정을 해버리면 그니까 그 32 bit 단위로 봤을 때 좀 일관되지 않은 구조가 나오니까 이해보수를 사용하면 사실 맨 앞에 bit가 지금은 우연하게 사인 bit가 된 거지 그냥 이해보수 관점에서 보면은 모든 bit가 똑같은 그 레벨에서 사용되고 있는 거거든 그래서 그니까 우연하게 맨 앞에 bit가 일일 때는 음수고 영인 게 양수가 되는 거야. 

발화자 1 (23:03)
그게 원래 모여서. 

발화자 3 (23:04)
이렇게 고정된. 

발화자 1 (23:05)
은행 값이 아니라. 

발화자 3 (23:06)
음 그게 고정된 4인 bit를 위한 bit가 아니? 

발화자 1 (23:09)
이거를 음수랑 양수를 어떻게 표현할까 해서 이에 부수가 나왔는데 그거를 따지고 보니까 그렇게 된 거지? 

발화자 4 (23:17)
음 근데 제가 알기로 어 이 책을 읽었을 때 이게 이의 보수를 적용한 값은 아니면 원래 값인가를 구분을 하기 위해서 플래그라는 애가 또 있다고 들었어. 그러니까 그럼 그 플래그라는 애 하나만 가지고 음수 양수를 정하면 되지 왜 여기서 bit까지 건들지 막 이런 생각. 

발화자 3 (23:40)
플래그가 없어도 숫자는 알 수 있는데 정해진 bit 음수인지 양수인지 어떤가? 

발화자 5 (23:46)
나도 책을 봤을 때 문제가 양수에서 오랑 뭐 음수에서의 삼이랑. 

발화자 4 (23:52)
응, 그 구분이 안된다고 이제 bit가 똑같으니까 그것만 보고는 알 수가 없다. 

발화자 3 (23:57)
아 어 근데 bit 수가 아 bit 수가 고정돼 있는 걸 뭔가 플래그를 통해서 알 수 있는 건가 그거까진 나도 잘 모르겠네. 

발화자 5 (24:09)
bit 수가 없고 제가 어디 있어가지고 책 봐도 될 것 같습니다. 

발화자 3 (24:12)
금방 책을 마찬가지. 

발화자 4 (24:20)
지금 지금 녹음기가 되어 있어. 

발화자 5 (24:25)
네 이의 보수의 한계 60 페이지. 

발화자 1 (24:30)
응, 응, 여기 있네. 

발화자 4 (24:41)
앞에 필수 있는 거 들어와서 59 페이지에 맨 위쪽에 보면은 어. 

발화자 5 (24:59)
이 마이너스 일용일이를 표현하기 위한 음수로서의 영 일 01일삼 양수로서의 영일영일 어떻게 구분할 것인가? 

발화자 3 (25:12)
이건 뭐 5 플로 이상 안 값 아니야 그니까 bit 4 bit로는 4 bit로 표현했을 때는 무조건 십진수 오를 음 의미하고 중의적인 다른 수로 해석이 될 여지가 없지 않아 뭐 사bit 고정이라고 하면. 

발화자 4 (25:38)
전기라고 하냐. 

발화자 1 (25:41)
신조어를 표현하기 위한 야수 있는 먹는 진짜. 

발화자 3 (25:47)
그니까, 지금 앞에서 101일에 마이너스 붙인 거를 영일영일로 번역을 했다고 한거잖아 그럼 마이너스 101일이 십진수로 표현을 하면 일이에 8에 마이너스 붙인 거니까 마이너스 11. 

발화자 1 (26:01)
음 이게. 

발화자 4 (26:04)
음 이 어 그치 많이. 

발화자 3 (26:06)
마이너스 11은 이 4 bit로 원래 범위가 표현될 수 없는 범위인 거지. 마이너스 8부터 이해 칠까지만 표현 가능한 게 4 bit니까 그러니까 애초에 오버 블루 원인가 불러 온 거지. 지금 이거 이 질문을 한 사람 그러니까 이 사bit로 표현될 수 없는 범위야 애초에 이건. 

발화자 4 (26:29)
뭐 어떤 약간 질문이 없거네 없다인 거네. 

발화자 3 (26:33)
그러니까 그러니까 이해보수 체계에서는 정해진 엔 개의 bit로 표현할 수 있는 수의 범위가 정해져 있기 때문에 그래서 중의적인 bit가 존재할 수 없어. 

발화자 4 (26:43)
음 

발화자 3 (26:53)
일단 제 생각에 그래요. 

발화자 2 (26:55)
연결되었나요? 

발화자 4 (26:57)
어 

발화자 5 (26:57)
어 근데 근데 왜 시간이 설명을 이렇게 있을까? 

발화자 3 (27:00)
독자가 엇까지는 그. 

발화자 4 (27:04)
자 억 가지고 넣어놔서 강의 보기 할려고 그런 거 아닐까? 

발화자 3 (27:08)
근데 헷갈릴 수 있으니까 5분 플로 언더 블루 개념 그리고 정보 같은 경우 bit 수가 정해져 있을 때 수의 범위를 어떻게 뭔가 이렇게 경계를 나눌 수 있을까? 

발화자 1 (27:19)
플로우란 말을 그렇게 나한테 많이 썼으면서 저렇게. 

발화자 2 (27:25)
응 

발화자 1 (27:26)
아 네 계속 오버플로 일어났다면서. 

발화자 4 (27:29)
하하하 아. 

발화자 3 (27:31)
MBTI로 일단 다음 질문 네. 

발화자 2 (27:35)
다음 내용으로 정수형 자유를 bit로 어떻게 관리하는가 32 bit 인트 작용은 각 bit를 어떤 용도로 사용하여 수를 표현하는가 입니다? 그래서 저는 32 bit인트는 최상위 1 bit를 95 bit로 나머지 31 bit는 수의 크기를 표현한 데 사용한다라고 작성을 했거든요. 이제 다른 분들 다 혹시 저랑 다르게 작성하세요. 

발화자 4 (28:09)
그래서 이제 카테오 이제 비슷한 것들이게 문제가 진짜 갸우뚱하게 만드는 느낌. 

발화자 1 (28:17)
그래서 약간 답이 정해져 있는 그런 거라. 

발화자 3 (28:21)
사실 위에 거랑 이어지는 거라서 한번 인트 자료형이 어떻게 되는지 검색해봐서 좀 실제 프로그래밍 언어랑 이론으로 배운 이해 보수랑 어떤 차이가 있는지 좀 검색해보라고. 

발화자 5 (28:34)
어 나 인제 나인데 이해. 

발화자 3 (28:36)
어 그래서 나는 C 언어로 출력을 해봤어. 실제로 이의 보수를 따르고 있는지 bit 연산해 가지고 0번 시프트부터 31번 시프트 해보면서 bit 값 출력해보는거를 이에다가 이의 모습 어떤 게? 

발화자 1 (28:52)
자바에서 임팩트를 잡아야 할 때 bit필드. 

발화자 3 (28:56)
그래서 넷이 피오는 이의 모습을 사용하는가 마이너스 30을 bit로 출력을 했을 때 저렇게 출력이 되더라 저기 딱 이해 보수에 맞더라. 

발화자 5 (29:09)
음 라이젠 해일리가 말한 그 우연적으로 32 bit가 그걸 왠지 이해했네. 외연적으로 바지를 보호비트를 쓰는 거예요. 

발화자 3 (29:18)
그치 음 의도적으로 그렇게. 

발화자 5 (29:21)
어쩌다 보니까 목이 또 이렇게 쓰이는 거예요? 

발화자 1 (29:23)
뭔가 그 숫자를 표현을 하는 데 있어서 그냥 일반적으로 인제 그 2의 영승부터라고 계산이 되지 않습니까? 그 제일 오른쪽부터 이에 영승 이에 일 승 이에 이승 이렇게 해서 그걸 다 더한 값이 그 값이 되는 거니까 인제 근데 거기서 이게 음수로 뒤집을 때 이게 전화를 시키면은 그게 앞에 있는 영이라는 그 숫자가 일로 변하는 거니까. 그렇게 될 수밖에 없어. 

발화자 5 (29:49)
어 맞네. 책이 좀 너무 쉽게 설명해 가지고 헷갈려서. 

발화자 1 (29:53)
플레이드는 나중에 붙인 거지. 그러니까 그 보수 어 이거를 그러면은 이렇고 이에 영승 그거 해서 이렇게 표현을 하자 근데 이걸 이제 음수를 표현하면 어떻게 해야 될까 해서 그걸 정했는데 정하고 보니까 영과 일이었던 음 음 따로 나와 있지가 않다. 

발화자 2 (30:11)
둘 다 알아. 

발화자 3 (30:13)
나중에 이거는 좀 더 딥 라이브이긴 한데 더블 플로트형 자료 구조가 각 bit를 어떻게 사용하고 있는가를 각자 한번 딥 다이브 해보는 걸 추천 추천드립니다. 네 더블 플로트 둘 다 똑같아요 플로트 자료 고정과 각 bit를 어떻게 숫자로 표현하고 있는 거. 

발화자 2 (30:34)
가요. 

발화자 3 (30:36)
아 타입 타입. 

발화자 2 (30:38)
아이비 밥. 

발화자 3 (30:40)
하이 빅스비가 어떤 용도로 사용하고 있나요? 

발화자 1 (30:44)
그러게 아, 이게 저게. 

발화자 3 (30:46)
이건 전 전체. 

발화자 1 (30:47)
그게 아니라 실수용으로 하면은 또 다르겠구나. 

발화자 5 (30:51)
부동수도 좀 봐요. 

발화자 3 (30:52)
음 아동에서 생성. 

발화자 1 (30:53)
부정 소수점 그게 제한인 것도 있으니까 이거 어떻게 될 건지에 따라서 다르겠네. 

발화자 3 (31:01)
저걸 알면 얼마나 플로팅 포인트가 불안한 숫자인지. 

발화자 5 (31:07)
플라잉 보니까 무덤도 있죠? 

발화자 1 (31:08)
응 부담스럽죠. 

발화자 3 (31:10)
그치 어. 

발화자 2 (31:13)
맞습니다. 혹시 이거 이 그림 맞나요? 다른 거야? 

발화자 3 (31:22)
아 어 맞아요. 

발화자 4 (31:24)
1 학년 때 배우던 거 그와 피티스드 온다. 

발화자 3 (31:30)
네 이거 맞아요. 나중에 한번 찾아보시고. 

발화자 2 (31:35)
네 

발화자 5 (31:36)
아시나요? 근데 부동산 전문들을 잡아서 어떻게 해결하는지? 저는 BT BT 미콘이라는 친구를 이용해서. 

발화자 3 (31:44)
디피지만. 

발화자 5 (31:45)
어 아 BT시바. 

발화자 1 (31:46)
이해 드시고요. 

발화자 5 (31:48)
그 친구는 어떻게 동작하는지 찾아보면 되게 재밌더라고 어 그냥 제가 그냥 개발 간단하게 알기로 그냥 다 때려 박는 걸로 아는데 그대로 그대로 저장하는구나 엄청난 메모리를 써가지고 일단. 

발화자 3 (32:02)
빅 인티적 이런 거를 그 기본 인트 타입으로만 직접 구현을 해보는 걸 추천을 해 100주 문제 큰 수의 합이라는 문제가 있거든 그러면 그니까 파이썬 같은 거 쓰면은 자동으로 빛 그니까 숫자의 범위가 무한이 돼도 파이썬은 막 FFT를 이용을 해서 큰 수의 연산을 빠르게 해둔단 말이야. 최적화해서 그런 거 말고 순수하게 인트 자료용만 사용해서 자바에서. 

발화자 1 (32:31)
민트를 사용해서 빅 인티저를 하고 있. 

발화자 3 (32:33)
그 지피 인 디저를 한번 구현을 해 본 연습을 하면 그게 실제로 빅디시멀이 어떻게 구현되어 있는지 이해하는 데 좀 도움이 될 것 같고. 

발화자 4 (32:42)
이태원 가지 어떻게 해 어떻게 하지? 

발화자 2 (32:48)
응 

발화자 3 (32:49)
오케. 

발화자 2 (32:50)
혹시 궁금한 게 없나요? 

발화자 5 (32:52)
네 고맙습니다. 

발화자 2 (32:54)
마지막 이유 이 시기에 의한 유니코드 유티의 폭발이 각각 무엇인가 인식해야 한글 유니크 전 세계 문자 슈퍼 유티에팔 감기리 인코딩 망신. 

발화자 5 (33:08)
그래서 이때 팔이랑 16 이랑 32는 기본 단위의 bit 수를 의미한 몇 가지 점수를 했어요. 난 그래서 그래서 인코딩을 래ft로 할 것인가에 대한 얘기더라. 

발화자 1 (33:22)
맞아. 

발화자 5 (33:22)
그래서 UTF 32는 한글을 주로 쓰는 것에서 유리하다고 들었어요. 왜냐하면 기본적으로 답이 투 때려 보이니까 되게 편하지 아니요. 아니 근데 이제 파는 영어를 많이 쓰는 거에서 되게 효율적으로 하기 위해서 하는 걸로 봤어. 

발화자 1 (33:36)
그리고 UCK 아 그 이유CKR 거기 책에 나와 있는 게 와이 성경 인코딩이라는 말이 나와 있어서. 

발화자 4 (33:44)
응 응, 맞아. 

발화자 1 (33:45)
그래서 완성형님 코딩이라는 것도 적어주면 좋을 것 같습니다. 

발화자 5 (33:50)
대응 못한다는데 백이라는 단어를 표현할 수 없다고 생각합니다. 

발화자 1 (33:53)
랩이 안 돼. 그러니까 기존에 그 완성된 글자에다가 번호를 부여하기 때문에 조합 형식이 아니기 때문에 새로운 거기 정의되지 않는 집합이 정의되지 않는 게 있으며 이제 표현을 할 수가 없는 거지. 그래서 2350개 정도의 한글 단어를 표현할 수 있다라고 나와 있습니다. 

발화자 4 (34:11)
그런 의미에서 뭐 인텔리제이에서 UTF 팔을 쓰고 이게 우리 프리코스 할 때 한글 깨지는 현상이 나오는 게 뭔가 이거랑 관련이 있지 않을까 싶은데 갑자기 생각이? 

발화자 3 (34:26)
어 회원님? 

발화자 5 (34:26)
어 YouTube에서 OTF 할 수 있는 이유가 영어라서 들릴 수도 있고 그. 

발화자 4 (34:31)
명령어가 거의 다 영어라서 그냥 LT 파파를 쓴 건가 효율적으로 하죠? 

발화자 5 (34:35)
이게. 그래가지고 여긴 궁금증이 있는데 내가 알기로는 이제 윈도우랑 애플 간에 완성형 인코딩인데 종합형 인코딩인데 차이가 있는 있나 조사해보지 않았어. 뭔가 내가 알기로 윈도우랑. 

발화자 3 (34:52)
그렇죠 그렇지? 

발화자 5 (34:53)
어 있어. 

발화자 3 (34:54)
윈도우로 유니코드는 한글을 완성형으로 쓰지 않나 원상형 인코딩 방식으로 번역하자. 

발화자 5 (35:01)
어 그거 맞아 그래? 

발화자 3 (35:02)
맞아. 

발화자 1 (35:02)
응, 유니코드도 완성명이야. 

발화자 3 (35:05)
그러니까 유니포드는 문자집합이고 UTF 8은 그 문 인코딩한 방식인 거고 이게 다른 건가요? 

발화자 1 (35:11)
아 감사합니다. 집합이고. 

발화자 3 (35:14)
그치 유니코드는 그냥 문자 표야. 문자표 어떤 문자들이 정의가 돼 있는 건가? 

발화자 5 (35:19)
어 그때 음 윈도우랑 맥이랑 유니코드 쓰던. 

발화자 1 (35:24)
아니요 윈도우랑 맥이랑 달랐던 게 그 우리 프리코스 때도 오려나셨던 게 윈도우랑 맥이랑 달랐어 그니까 맥은 괜찮았는데 왜냐면 난 맥에서 따로 설정을 안 했거든 근데 나 윈도우로 처음에 프리코스 했었을 때는 계속 터졌어 미* 듯이 어 그래서 인코딩 방식을 아예 바꿔야 된다고 했었거든 음 그게 차이가 확실히 있는 것 같아 어 왜냐면 어찌 됐든 맥을 만든 거는 맥을 만든 회사랑 맥의 이제 기본 바탕은 영어 있잖아요. 

발화자 4 (35:57)
찾아봤는데 한글 윈도우는 따로 지정을 안 하면은 씨피 구사구라고 이유시케이엘의 확장판을 사용을 한대 따로 YouTube 팔 세팅을 안 해주면은. 

발화자 1 (36:11)
EUCK 확장판. 

발화자 4 (36:19)
음 이건 뭘까 UTF 8 인코딩에서 NFC와 NFD의 로마 폼이 다 했는데 음 엔에프디에서 간단히 처리할 수 있는 연산 드DNFC는 귀찮다고 NFT를 사용한다. 어. 

발화자 3 (36:41)
윈도우스 윈도우가 기본적으로 이유씨 KR 또는 씨P 구사구를 쓰는데 이게 유니코드와 호환되지 않는데 응 그래서 아마 인텔리제이에서 유티에프팔을 기본으로 쓰기 때문에 UTF 팔은 문자 집합이 유니코드일 때만 인코딩을 할 수 있거든 그래서 문자가 깨지는 걸 거야. 문자 집합을 뭘 쓰냐에 따라서 인코딩 방식이 일치해야 되거든 그 문자 집합을 사용할 수 있는 리코딩 방법. 

발화자 4 (37:08)
니 노말 풍이 뭐지? 

발화자 3 (37:10)
음 맞아 응 그래서 이유씨 KR 쓰고 있기 때문에 UTF 8 인코딩 방식을 쓰면 반영이 안 된다 깨져서. 

발화자 4 (37:21)
음 그래서 엄청. 

발화자 1 (37:23)
응 열심히 적어도. 

발화자 3 (37:25)
문자집합이 어떤 종류가 있는지 인풋 그 문자 집합에 따라서 얘네들을 인코딩할 수 있는 방법이 뭐가 있는지는 따로 알아야 돼. 

발화자 5 (37:33)
응 그래서 그거 아이디 그레이드 빌드 하는 거 인텔리즈로 바꾸면 되는 건가 음 그레이드를 좀 배지 윈도우 거니까. 

발화자 1 (37:43)
아 여기 그 내가 윈도우 설정할 때 했던 걸 여기다 싹 적어놨거든 다 근데 ETF 8로. 

발화자 4 (37:50)
변경하는 그런 옵션들이. 

발화자 1 (37:51)
맞아 그 그러면은 글로벌 인코딩 프로젝트 인코딩 기폴트 인코딩을 다 UTF 8로 변경을 해야 되고 음 그 VVM 옵션에서 이제 또 다 보유티브 파일 추가해줘야 되고 그래 그리고 제어판에서도 유니코드 UTF 8 사용 체크를 해요. 

발화자 3 (38:07)
했어 음 어 맞아요? 그게 인텔리제이가 UTF 8을 쓰고 있기 때문에 삼성을 다 UTF 파는 거예요. 

발화자 1 (38:14)
엄청 좋았던 것 같아요. 

발화자 4 (38:17)
그리고 논알폼이라는 개념이 또 있대요. 얘는 문자열을 정규화된 형태로 나타내는 것을 의미를 한다는데 그래. 가지고 이거 이게 인코딩이 됐더라도 이런 방식에 따라서 문자를 나오는 게 다르다라고 얘기를 하는데 그 대표적인 게 맥에서 만든 파일을 윈도우에서 볼 때 한글이 그 따로따로 나오는 거 있잖아 그런 현상? 

발화자 1 (38:42)
아 이렇게 약간 초성 중성 중성으로 나뉘어서. 

발화자 4 (38:47)
미음 아 막 미음 이런 식으로. 

발화자 1 (38:49)
아 그게 완성형이냐 이제 그거냐 조합하고 달라지. 어 종합형이냐에 따라 달라지는 거. 

발화자 3 (38:55)
뭐가 있어요? 

발화자 4 (38:55)
토탈 인코딩 안내소에 노말 폼이라는 개념 때문에 생기는 걸로 나오는 거 같아. 

발화자 1 (39:01)
근데 잠시만 18근데 그거 차이인 것 같은데 완성형이냐 조합형이냐 그 조합형을 원래 쓰고 있었어. 근데 이제 완성형은 한 거에 하나만 인식이 되잖아 이제 그거를 하나로 인식시켜. 

발화자 3 (39:17)
어 맞네. 

발화자 4 (39:18)
그런 거 같아요. 제가 얘기 이거를 찾아보니까. 어 조합형 완성형의 차이인 것 같아. 

발화자 5 (39:22)
음 좋아 메이 라민도? 

발화자 1 (39:24)
그러니까 이게 조합형을 사용을 하고 있었어. 근데 그걸 이제 완성형을 쓰는 걸로 바꿔버리면은 완성명은 한 글자를 하나로 인식을 하잖아 근데 거기는 뭐 예를 들어서 간이라는 걸 하면 기윽 아 니은을 합쳐서 하나의 글자를 만들지만 그걸 하나하나 하나의 인식으로 하기 때문에 완성형은 그래서 이렇게 끊어져서 나오는 게 아닌가? 

발화자 3 (39:46)
어 그 메기 맥이 조합형이야. 

발화자 1 (39:48)
웩이 조합형 아닐까? 근데 왜냐하면 엄밀히 말이 조합형이 맞지 왜냐하면 우리나라는 그 한계를 포함하기 위해서는 초성 중성 중성이 나눠져 있지만 영어는 ABCD 이가 합쳐져서. 

발화자 3 (40:00)
근데 문 어. 근데 사실 맥이라고 해서 뭔가 특별하게 유니코드가 아닌 다른 문자 집합을 쓸까 싶어서. 

발화자 5 (40:08)
그럼 지금 레이스피 노트북으로 백 안 돼 배그 100. 

발화자 3 (40:13)
백 아닌데 잘 되지? 

발화자 1 (40:15)
어 맞네 맥이 유니코드 NFD를 사용해서 조합형 인코딩 방식을 사용한대. 

발화자 3 (40:20)
유니코드 안에서도 뭔가 조금. 

발화자 1 (40:22)
그 어 맞아 그리고 완성형이 아니었어. 

발화자 3 (40:25)
아 유니버는 계속 확장이 가능한. 

발화자 1 (40:28)
그래서 하나하나 다 정리가 돼 있고 기 가나다라와사 가나다라와 막 그 이렇게 따라 있거든 그래서 그게 다 따로따로 돼 있어서 근데 맥이 조합형이 맞고 윈도우에서 사용하는 NFC의 방식과 차이가 있다는 거 보니까 조합형하고 완성형 차이인 것 같아. 

발화자 3 (40:45)
응 맞아 이TF 파는 그래서 무한하게 B 수를 늘려가면서 확장할 수 있는 확장성을 가지고 있기 때문에 그게 가능한 거 같애. 

발화자 1 (40:54)
맥이 한글 자물을 개별적으로 분류해서 저장하고 그 NFC 유니푸드를 완성형으로 처리하는 방식으로 한글 자음으로 와서 하나의 원석의 글자로 저장한다. 어 맞는 거 같애 딱 그 그거 문제인 것 같애 조합형을 원래 맥에서 썼었는데 그걸 윈도우로 옮기면 윈도우는 그 하나하나를 글자 하나하나로 인식하기 때문에 분리되는 거죠. 딱 그거야. 

발화자 5 (41:16)
어 내가 알고 있는 듯이 맞았네. 결론은 맞았네 과정으로. 

발화자 3 (41:22)
네 아무튼 가장 널리 사용되는 ETF 8. 

발화자 1 (41:25)
근데 이게 유니코드도 그 유니코드를 조합형으로 처리하냐 원성형으로 처리하냐에 따라서 방식이 달라지는 것 같아 그 어 롤몰. 

발화자 3 (41:36)
아 오말라이즈 오만 오말라이제이션. 

발화자 1 (41:39)
응, 그 다음에 D랑 씨로 돼 있는 거 같애. 

발화자 3 (41:44)
오케이 일리코드 종류가 다양하네. 

발화자 1 (41:46)
음 이게 아 그래서 자소 분리 문제가 생기거나 유니코드 인코딩 방식을 다르게 한 거래 조합형인지 완성형인지 아니 유니코드라고 해서 그게 주어진 건 아닌 것 같아 방식이 유닛 그냥 유니코드는 그 어 문자 집합을 어떻게 저장하느냐 차이야 그러니까 저장 형식의 차이인 것 같아 유니코드는 이제 그거를 개별적으로 다 저장을 하는 거고 이제 하나의 완성된 단어로 저장을 뭐지? 아까 전에 그 이유시 이유시가 하나에 완성된 걸로 저장을 하는 거고 이제 유니코드는 하나하나하나하나를 다 저장을 하는 건데 이제 그걸 읽는 방식이 다른 거지 유니코드를 사용한다고 해서 그걸 조합으로 할 수도 있는 거고 완성으로 할 수도 있는 거고 그러니까 뭐 어떤 단위로 끊느냐 같은데 어 끊기 단위가 달라지니까 그게 자서 분리가 늘어난 것 같아 그래서 문자 집합이라는 표현을 그래서 문자 집합이라는 표현을 쓰는 거다. 

발화자 4 (42:41)
항상 종합형인지 완성인지를 따지는 세팅이 따로 있고 밑에도 8인지 16이 32 in를 정하는 세팅이 따로 있어서 그 2개 합쳐가지고 만들었다. 

발화자 1 (42:49)
근데 안 맞아, 그런 거 같애 아 맞아 그건 거 같애 그니까 딱 그 어떻 그러니까 정확히 이야기를 하면 그냥 집합하고 그 집합을 어떻게 끊어서 이해를 할 것이냐 그니까 딱 그 차이인 것 같애. 

발화자 5 (43:04)
결론을 낸 거 같아서 낸 거 같은데 미안한데 뭔가 불실 시킬 수 있을 것 같은 거 있어서 미안한데 내가 알기로는 그리고 또 또 하나 또 궁금증이 되게 별개인 이야기거든 그리고 내가 데이터베이스 설정을 할 때 이모티콘을 표현하기 위해서 UTF 파일 MB포라는 걸 설정했단 말이에요 그 마이 에스큐엘에 이 친구랑 유테이프 파일 차이를 막 검색해 보니까 또 머리가 아파 그래서 또 봐도 되고 안 봐도 될 거 같애 음, 나중에 되게 종류가 되게 많은 것 같아요. 

발화자 3 (43:33)
아 맞아 애니코트 들어. 

발화자 5 (43:35)
UTFR MB4. 

발화자 1 (43:36)
은지 에스파 앤드가. 

발화자 4 (43:38)
아 이거. 

발화자 5 (43:39)
그 친구를 넣으면 이모지를 해석할 수가 없어요. 

발화자 3 (43:42)
어 어려워 역시 무한이 확장 가능한. 

발화자 1 (43:46)
이 유니코드가 미* 뒤에 확장되는. 

발화자 5 (43:50)
아니 유니코드를 쓰는 건가 그러면? 

발화자 1 (43:52)
그 그러니까 유니코드는 확실하게 다 쓰는 게 맞는 것 같아요? 왜냐하면 현대 문제를 표현할 때 가장 많이 사용되는 표준 문자 집합이라고 했거든 인코딩 방식이 아니라 집합이라는 표현을 썼으니까 유니코드라는 문자 집합을 사용하되, 그거를 어떤 인코딩 방식으로 해석하느냐에 따라서 달라지는 게 아닐까? 

발화자 4 (44:10)
응, 맞는 거 같아. 

발화자 1 (44:13)
맞아 맞아 어 그건 거 같애요. 

발화자 5 (44:15)
아 그러면 또 배워가네요. 리코드는 기본이고. 

발화자 3 (44:21)
그러니까 계속 가격이 떨어 달라서 그렇구나 근데 좀 특이했던 건 UTF 32는 무조건 한문자동 사이바 사B 고정길이더라고 어. 어. 음. 

발화자 1 (44:32)
아 딱 그거네 그러니까 이유 이유씨랑 UTF 8이 그냥 인코딩 방식이고 유니코드는 그냥 문자 집합이고 그리고 아 여 그 이유시에서 말하는 문자 집합에 정의되지 않은 글자는 표현할 수 없다라는 게 이 문자 집합이 그 유니코드 문자 집합을 의미하는 게 아니라 이 이유씨에서 정의하는 문자 집합을 말하는 것 같아 어 그렇죠 유니코드를 말하는 게 아니라 그냥 이유시에서 내가 이거를 내 문자라고 정의를 할 거야라고 하는 걸 말하는 것 같아요 아 그 차이네. 

발화자 5 (45:09)
유니코드 안에 이유씨가 있는 건가? 

발화자 1 (45:11)
그건 아니지 아니 아니 관리. 

발화자 5 (45:13)
네 최대 수 있는 병습니다. 

발화자 1 (45:15)
코드 예를 들어서 유니코드가 그러니까 번호를 매겨서 얘 일이삼이야. 근데 이제 완성형은 1 2 3을 하나로 묶어서 하나의 단어로 칠 거야라고 이제 정한 거고 그리고 이제 조합형은 얘랑 얘랑 얘랑 다른데 내가 조합했을 거야. 이거 이건 거니까 그러니까 다 각각 하나의 문자로 치느냐 그 그냥 묶음 다리. 

발화자 3 (45:37)
뭐 글자를 조합하는 건 다른 걸 수도 있는데 근데 이제 호환되는 문자집합도 있기는 해 이씨케이알 리아스키를 후원하듯이 근데 유니코드는 이유시케이알을 떠나지 않는다. 그러니까 2개는 문자 집합에 대응되는 숫자가 다르다 음. 

발화자 5 (45:56)
가스키 코드 유니코너랑 다른 거 같다. 

발화자 3 (45:58)
아스키 코드는 활용화되어 유니코드가 호환하고 있어 자 다른 문자 집합인데 문자 집합의 크기가 다른 거지? 근데 아스키 코드는 이유씨케이알도 호환이 되고 유니코드도 호환이 되게 돼 있어 이제 표준이라서 어떻게 보면 아세요. 

발화자 4 (46:12)
코드가 호환이 됩니다. 

발화자 3 (46:14)
마지막 문자 문자 네 문자 집합이 똑같은 숫자의 래핑이 되게 만들어 남기고 하죠. 

발화자 4 (46:20)
된다드라. 

발화자 5 (46:22)
아 마스크가 더 좋은 건가? 

발화자 3 (46:23)
아니 아스키보드가 훨씬 적시 문자. 

발화자 1 (46:25)
그러니까 문 문자 집합이 그 적고 그건 되니까 약간 디폴트인 거고 그 디폴트를 포함해서 유니코드는 계속하고. 

발화자 4 (46:33)
유니 코드는 넓은데 아스키는 128개국까지 밖에 없어. 

발화자 3 (46:37)
그러니까 영어는 다 이제 세계 공통 언어다 보니까 웬만하면 이제 눈치를 보면서 아스키는 다 호환이 되게 만든 거지. 영어는 어디서든 많이 쓰기 때문에 이제 한글 같은 경우는 우리나라만 쓰기 때문에 호환시켜서 유니쿠스를 안 만든 거고 영향력이 적기 때문에 좋은데요 네. 

발화자 1 (46:56)
그래서 보기 전에. 

발화자 3 (46:57)
되는 것 같습니다. 

발화자 4 (46:58)
국가에서 아스키를 쓰는 이유가 뭔가 우리 뭐 보통 응 뭐라 뭐 호텔 같은 거 하다 보면은 이제 막 만날 때 막 65 빼가지고 막 영어 출력하고 그런 일 있잖아. 

발화자 3 (47:11)
한 이유는 이제 캐릭터 타입이 일 B이기 때문인지 일 B는 팔 bit인데 아스키 코드가 8 8 B로 표현할 수 있는 이제 가장 표준 표준 문자 지피비 분자 집합이기 때문에 최대한. 

발화자 4 (47:24)
유니콘을 못 쓰는 상황이구나. 

발화자 3 (47:25)
음 애초에 유니코드가 미투수가 부족해서. 

발화자 4 (47:28)
그래서 아스키를 쓰는 거고 오케이 마스크를. 

발화자 2 (47:33)
진짜? 

발화자 1 (47:35)
재밌는 사실을 알았네요? 

발화자 2 (47:38)
아주 알차분해. 

발화자 1 (47:39)
굉장히 알찬 시간이었어요. 

발화자 3 (47:41)
그러면 이제 우리. 

발화자 1 (47:43)
질문을 저는. 

발화자 3 (47:44)
중요하다. 질문만 그치. 

발화자 4 (47:45)
일단은 녹음은 마칠게요. 

발화자 5 (47:47)
네 
