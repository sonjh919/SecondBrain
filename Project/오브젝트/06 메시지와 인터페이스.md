---
title: 06 메시지와 인터페이스
date: 2024-01-15 12:15
categories:
  - OOP
  - 오브젝트
tags:
  - OOP
  - 객체지향
  - 개발서적
image: 
path:
---
어플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다.

## 협력과 메시지 : 클라이언트-서버 모델
두 객체 사이의 협력 관계를 설명하기 위한 전통적인 메타포로 클라이언트-서버 모델을 들고 왔다. 이 예시를 듣자마자 책이 이야기하고자 하는 바를 단숨에 이해함과 동시에 내가 또 한 단계 나아갔다는 생각이 들었다. 그동안 어떻게 보면 백엔드 내에서만 객체지향을 생각하고 있었는데 어플리케이션 전체로 넓히니 프론트와 백엔드와의 관계도 API라는 메시지를 통해서 협력을 주고받기 때문에 객체지향적이라고 할 수 있는 것 같다. 덕분에 보다 넓은 시야로 프로그램을 다시 바라볼 수 있게 되었다.


## 메시지 전송
메시지 전송(패싱)은 메시지 수신자, 오퍼레이션명, 인자의 조합이다.
메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메소드라고 한다.

```
// 수신자.오퍼레이션명(인자)
condition.isSatisfiedBy(screening);
```

계산을 **메시지와 메서드로 분리하고 실행 시간에 수신자의 클래스에 기반에서 메시지를 메서드에 바인딩하는 것**은 작은 변화처럼 보이지만 커다란 차이를 만든다!
## 퍼블릭 인터페이스와 오퍼레이션
**메시지가 객체의 품질을 결정한다.**
### 퍼블릭 인터페이스
객체가 의사소통을 위해 외부에 공개하는 **메시지의 집합**

### 오퍼레이션
프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지, 수행 가능한 어떤 **행동에 대한 추상화**

UML의 공식 정의는 **실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세**이다.
인터페이스의 각 요소는 오퍼레이션이다. 오퍼레이션은 구현이 아닌 추상화이며, 메서드는 오퍼레이션을 구현한 것이다. 메서드는 오퍼레이션과 관련된 알고리즘 또는 절차를 명시한다.

### 시그니처
오퍼레이션(메서드)의 이름과 파라미터 목록(명세)을 합쳐 시그니처(signature)라고 한다.
오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것
메서드는 시그니처에 구현을 더한 것.


## 인터페이스와 설계 품질
좋은 인터페이스는 **최소한의 인터페이스**와 **추상적인 인터페이스**를 만족해야 한다.
최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다.
추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.(how/what)

이 둘을 만족시키기 위한 가장 좋은 방법은 **책임 주도 설계**이다. 물론 이것도 좋지만, 훌륭한 인터페이스의 공통적인 특징을 아는 것도 중요하다.

### 디미터 법칙
협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이다.
객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 것이다.

**"낯선 자에게 말하지 말라"**
**"오직 인접한 이웃하고만 말하라"**

디미터 법칙을 따르면 부끄럼타는코드(shy code)를 작성할 수 있다. 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.

디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다. 캡슐화는 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면 디미터 법칙은 **협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한**한다.

> 무지성으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수도 있다.
{: .prompt-warning }
#### 기차 충돌
메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환하는 요소에 대해 연쇄적으로 메시지를 전달하는 것. 내가봐도 보기 싫은 코드이다... getter의 향연이란...
```java
screening.getMovie().get~.get~
```

사실 디미터의 법칙과 "묻지 말고 시켜라" 두 내용이 같다고 착각하고 있었다. 하지만 이 책을 보니 다르다는 것을 알았다. 그런데 이번 팀 프로젝트를 하면서 설계에 대해서 고민하다 보니 어느새 이 두 개념에 대해 자연스럽게 깨닫고 적용시킨 것을 알았다. 내가 공부를 하고 적용시켜 보는 것 보다 **먼저 고민해본 후 적용시킨 다음에 공부하는 과정에서 해당 개념이 이미 있던 것임을 깨닫고 정리하는 과정**. 내가 원하는 이상적인 공부를 하고 있는 것 같아 기분이 좋다.

### 묻지 말고 시켜라
훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다.

**절차적인 코드는 정보를 얻은 후에 결정한다. 객체지향 코드는 객체에게 그것을 하도록 시킨다.**

이 스타일은 객체 간의 상호작용을 getter의 체인 속에 암시적으로 두지 않고 좀 더 명시적으로 만들고 이름을 가지도록 하는 이점도 있다.

### 의도를 드러내는 인터페이스
메서드가 작업을 어떻게 수행하는지를 나타내는 방법은 커뮤니케이션에 힘들고, **메서드 수준에서 캡슐화를 위반한다.**

#### 의도를 드러내는 선택자(Intention Revealing Selector)
**어떻게(how)가 아니라 무엇(what)** 을 하는지를 드러내는 메서드 명명법을 사용하자.

>
하나의 구현을 가진 메시지의 이름을 일반화하도록 도와주는 간단한 방법 : **매우 다른 두 번째 구현을 상상하고 해당 메서드에 동일한 이름을 붙여보자.**
{: .prompt-tip }

이것을 인터페이스 레벨로 확장하면 **의도를 드러내는 인터페이스**가 된다. 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는 것이다.

## 원칙의 함정
**설계는 트레이드오프의 산물이다.** 초보자는 원칙을 맹목적으로 추종하여, 적용하려는 원칙들이 충돌하는 경우에도 억지로 끼워 맞추려고 노력한다고 한다.

원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하자. 원칙을 아는 것보다 중요한 것은 **언제 원칙이 유용하고, 언제 유용하지 않은지를 판단할 수 있는 능력을 기르는 것이다.**(나에게 아직은 부족한 능력..)

### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다.
기차 충동처럼 보이는 코드도 **객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면** 그것은 디미터 법칙을 준수한 것이다.

```java
IntStream.of(1,2,3).filter(x -> x >10).distinct().count();
```

모두 동일한 클래스의 인스턴스를 반환한다. 이 과정에서 **내부 구조가 유출**되지도 않았다. 객체를 둘러싸고 있는 캡슐은 그대로 유지된다.

### 결합도와 응집도의 충돌
일반적으로 어떤 객체의 상태를 물어본후 반환된 상태를 기반으로 결정을 내리고 그 결정에 따라 객체의 상태를 변경하는 코드는 "묻지 말고 시켜라" 스타일로 변경해야 한다.

**위임 메서드를 추가**해 객체의 내부 구조를 감추는 것은 협력에 참여하는 객체들의 결합도를 낮출 수 있는 동시에 객체의 응집도를 높일 수 있는 가장 효과적인 방법이다.

하지만 맹목적으로 위임 메서드를 추가하게 된다면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션이 공존하게 될 수 있다. 무조건 디미터 법칙과 묻지 말고 시켜라 원칙을 따르면 어플리케이션은 응집도가 낮은 객체로 넘쳐나게 될 것이다.

### 경우에 따라 다르다.
가끔씩은 묻는 것 외에는 다른 방법이 존재하지 않는 경우도 존재한다. 물으려는 객체가 정말로 데이터인 경우도 있다. 디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료 구조인지에 달려있다. 객체는 내부 구조를 숨겨야 하기 때문에 디미터 법칙을 사용하지만 데이터는 당연히 내부를 노출해야 하므로 적용할 필요가 없다는 것이다. 객체에게 시키는 것이 항상 가능한 것은 아니다. 가끔은 물어야 한다.

**상황을 판단할 수 있는 안목을 기르자. 설계는 트레이트오프의 산물이다. 소프트웨어 설계에 존재하는 몇 안되는 법칙 중 하나는 "경우에 따라 다르다"는 사실을 명심하자.**

## 명령-쿼리 분리 원칙
명령-쿼리 분리 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.
가끔씩은 물어야 한다는 사실을 납득한 후 이 원칙의 필요성에 대해 알았다. 어떻게 보면 db를 연결해서 값을 가져오는 과정은 시키는 것이 아니라 묻는다는 쪽에 더 가까운 것 같다.

### 루틴(routine) & 프로시저(procedure) & 함수(function)
루틴은 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈로, 루틴은 다시 프로시저와 함수로 구분할 수 있다.
프로시저는 정해진 절차에 따라 **내부의 상태를 변경**하는 루틴의 한 종류다.
함수는 어떤 절차에 따라 **필요한 값을 계산해서 반환**하는 루틴의 한 종류이다.

>
>**프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.**
>**함수는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.**
{: .prompt-info }

### 명령(Command) & 쿼리(Query)
객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름이다. 객체의 상태를 수정하는 오퍼레이션을 명령이라 부르고 객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리라고 부른다.

>
명령 == 프로시저
쿼리 == 함수
{: .prompt-info }

**어떠한 오퍼레이션도 명령인 동시에 쿼리여서는 안된다.**
**질문이 답변을 수정해서는 안된다.**

이 개념을 보면서 다른 생각도 들었는데, 어떻게 보면 명령과 쿼리를 동시에 수행한다는 것 자체가 하나의 메서드가 여러 일을 수행하는 것이라는 느낌도 들었다. 역시 이것도 무의식적으로 고려하고 있던 사항이었다!

### 참조 투명성
**어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성**

참조 투명성은 식을 값으로 치환하는 방법을 통해 결과를 쉽게 계산할 수 있게 해준다.

### 부수효과
부수효과를 발생시키는 대표적인 두 가지 문법은 대입문과 프로시저이다. 어떤 값이 불변한다는 말은 부수효과가 발생하지 않는다는 말과 같다.

부수효과가 없는 불변의 세상에서는 모든 로직이 참조 투명성을 만족시킨다. 불변성은 부수효과의 발생을 방지하고 참조 투명성을 만족시킨다.

**객체지향의 패러다임이 객체 상태 변경이라는 부수효과를 기반으로 하기에 참조 투명성은 예외에 가깝다. 명령-쿼리 원칙을 이용하면 이 균열을 조금이나마 줄일 수 있다.**

### 함수형 프로그래밍
함수형 프로그래밍은 부수효과가 존재하지 않는 수학적인 함수에 기반한다. 그래서 함수형 프로그래밍은 참조 투명성의 장점을 극대화할 수 있으며 명령형 프로그래밍에 비해 프로그램의 실행 결과를 예측하기 더 쉽다.

## 정리
책임에 초점을 맞추자.
+ 디미터 원칙
+ 묻지 말고 시켜라
+ 의도를 드러내는 인터페이스
+ 명령-쿼리 분리 원칙

이 원칙들은 구현과 부수효과를 캡슐화하고, 높은 응집도와 낮은 결합도를 가진 인터페이스를 만들 수 있는 지침을 제공하지만 실제로 실행 시점에 필요한 구체적인 제약이나 조건을 명확하게 표현하지는 못한다. 즉 협력을 위해 두 객체가 보장해야 하는 실행 시험의 제약을 인터페이스에 명시할 수 있는 방법이 존재하지 않는다.

이를 해결하기 위해 **계약에 의한 설계** 개념이 등장한다. 이것은 나중에..부록을 들어갈 때 읽어보도록 하자.