---
title: 02 객체지향 프로그래밍
date: 2024-01-08 14:52
categories:
  - OOP
  - 오브젝트
tags:
  - OOP
  - 개발서적
  - 객체지향
image: 
path:
---

## 생성자
생성자의 파라미터 목록을 이용해 초기화에 필요한 정보를 전달하도록 강제하면 올바른 상태를 가진 객체의 생성을 보장할 수 있다. 자바의 가변인자(...)을 활용하면 여러 개의 인스턴스를 허용할 수 있다.


## 코드의 의존성과 실행 시점의 의존성
코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다. 이를 이용하면 유연하고 쉽게 재사용할 수 있으며 확장 가능한 설계가 가능하지만 코드를 이해하기 어려워진다.
**의존성의 양면성은 설계가 트레이드오프의 산물이다.**

설계가 유연할수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다.
유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다.
**항상 유연성과 가독성 사이에서 고민**하자.
무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다.

난 그동안 무조건 읽기 쉬운 코드가 좋다고 생각했는데, 읽기 쉽다는 것은 그만큼 유연하지 않다는 사실을 알았다.

## 상속과 인터페이스가 가치 있는 이유
부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다. (인터페이스는 객체가 이해할 수 있는 메시지 목록을 정의한다.)
**즉, 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문이다. 메서드나 인스턴스 변수 재사용이 주 목적이 아니다!**  이처럼 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 하고, 이것은 곧 **다형성**과도 관련이 있다. 

## 동적 바인딩
다형성은 **컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반**으로 한다.

다형성을 구현하는 방법은 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다. 즉, 메시지와 메서드를 실행 시점에 바인딩한다는 것이다. 이를 **지연 바인딩(lazy binding)** 또는 **동적 바인딩(dynamic binding)** 이라 부른다. 반면 전통적인 함수 호출처럼 컴파일 시점에 결정하는 것을 초기 바인딩(early binding) 또는 정적 바인딩(static binding)이라고 부른다.
일반적으로 상속을 이용해 다형성을 구현할 수 있지만, 상속만이 다형성을 구현할 수 있는 유일한 방법은 아니다.

## 구현 상속 vs 인터페이스 상속
상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다.
구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 확룰이 높다.

## 추상화의 힘
1. 추상화 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다는 것이다.
2. 추상화를 이용하면 설계가 좀 더 유연해진다.

추상화를 사용하면 세부적인 내용을 무시한 채 **상위 정책을 쉽고 간단하게 표현**할 수 있다. 즉, 필요에 따라 표현의 수준을 조정하는 것을 가능하게 해준다. 상위 정책을 기술한다는 것은 기본적인 어플리케이션의 협력 흐름을 기술한다는 것!
-> 재사용 가능한 설계의 기본을 이루는 디자인 패턴이나 프레임워크 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용하고 있기 때문에 매우 중요하다

## 유연한 설계
책임의 위치를 결정하기 위해 조건문을 사용하는 것은 대부분의 경우 좋지 않은 선택이다. 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하자.

오브젝트를 보면서 느낀 건데 클래스를 약간 메서드처럼 활용..?하는 면이 있는 것 같다.

**유연성이 필요한 곳에 추상화를 사용하자**

## 코드 재사용
코드 재사용을 위해서는 상속보다는 합성이 더 좋은 방법이다.
**합성 : 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법**

### 상속의 단점
1. 캡슐화를 위반한다. 부모 클래스의 구현이 자식 클래스에게 노출되어 변경이 어렵다
2. 설계를 유연하게 하지 못하게 만든다. 이는 부모와 자식 클래스 사이의 관계를 컴파일 시점에 결정하기 때문에, **실행 시점에 객체의 종류를 변경하는 것은 불가능**하다.

### 합성
상속은 부모 클래스의 코드와 자식 클래스의 코드를 컴파일 시점에 하나의 단위로 강하게 결합하는 데 비해 다소 약하게 결합된다는 것이다.
**인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성**이라고 부른다.
합성은 상속의 2가지 문제점을 모두 해결할 수 있다.

코드 재사용을 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다(**GOF94**)
하지만 그렇다고 상속을 절대 쓰지 말라는 말은 아니다. **대부분의 설계에서는 상속과 합성을 함께 사용**해야 한다.