---
title: 04 설계 품질과 트레이드오프
date: 2024-01-14 15:19
categories:
  - Book
  - 오브젝트
tags:
  - OOP
  - 객체지향
  - 개발서적
image: 
path:
---

설계는 변경을 위해 존재하고 변경에는 어떤 식으로든 비용이 발생한다.
훌륭한 설계란 **합리적인 비용 안에서 변경을 수용할 수 있는 구조**를 만드는 것이다. 적절한 비용 안에서 쉽게 변경할 수 있는 설계는 응집도가 높고 서로 느슨하게 결합되어 있는 요소로 구성된다.

결합도의 응집도를 합리적인 수준으로 유지하기 위한 중요한 원칙은 객체의 상태가 아니라 행동에 초점을 맞추는 것이다.

## 데이터 중심 설계 vs 객체 지향 설계
데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다. 너무 이른 시기에 내부 구현에 초점을 맞추게 되어 캡슐화가 완전히 무너지게 된다. 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.

**너무 이른 시기에 데이터에 대해 고민하지 말자.**
### 캡슐화 위반 1 : getter/setter
get과 set은 해당 인스턴스 변수가 존재한다는 사실을 노골적으로 드러낸다.
접근자(getter)와 수정자(setter)에 과도하게 의존하는 설계 방식(추측에 의한 설계 전략)은 협력을 고려하지 않고 객체가 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행한다. 그 결과, 캡슐화의 원칙을 위반하는 변경에 취약한 설계를 얻게 된다.

### 캡슐화 위반 2 : 파급 효과
```java
public class DiscountCondition{
	private DayOfWeek dayOfWeek;
	private LocalTime time;
	public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime time){...}
}
```

isDiscountable 메서드는 DayOfWeek 파라미터와 LocalTime 파라미터를 받음으로서 해당 클래스 내에 이들이 인스턴스 변수로 포함되어 있다는 사실을 인터페이스를 통해 외부에 노출하고 있다. 만약 속성을 변경할 일이 생긴다면, 메서드의 파라미터도 수정하고, 해당 메서드를 사용하는 모든 클라이언트도 함께 수정해야 한다. 이는 내부 구현의 변경이 외부로 퍼져나가는 **파급 효과(ripple effect)** 로, 캡슐화가 부족하다는 명백한 증거이다.

```java
public class Movie {  
    public Money calculateAmountDiscountedFee(){ ... }  
    public Money calculatePercentDiscountedFee(){ ... }  
    public Money calculateNoneDiscountedFee(){ ... }  
}
```

그럼 이 클래스는 어떨까? 나는 속성에 대한 어떠한 정보도 노출하고 있지 않기 때문에 캡슐화의 원칙을 지키고 있다고 생각했지만, 아쉽게도 틀렸다. 다음 세 개의 할인 메서드는 할인 정책에는 금액, 비율, 미적용의 세가지가 존재한다는 사실을 만천하에 드러내고 있다.
이럴 경우, 만약 할인 정책의 추가/제거 등이 이루어진다면 이 메서드들에 의존하는 모든 클아이언트가 영향을 받을 것이다. 따라서 이것은 성공적인 캡슐화라고 말할 수 없다.

## 설계 트레이드오프
좋은 설계를 위해서 변경점은 캡슐화하고, **높은 응집도와 낮은 결합도**를 가진 모듈로 구성해야 한다.
캡슐화의 정도는 응집도와 결합도에 영향을 미친다. 캡슐화를 위반하면 모듈 안의 응집도는 낮아지고 모듈 사이의 결합도는 높아진다. 따라서 캡슐화를 1순위로 향상시키기 위해 노력해야 한다.
### 캡슐화
변경될 가능성이 높은 부분을 구현이라 부르고 상대적으로 안정적인 부분을 인터페이스라 부른다.
객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화하는 것이다. 

**즉, 변경될 수 있는 어떤 것이라도 캡슐화해야 한다.** 
캡슐화는 유지보수성을 목표로 할 때 가장 중요한 동료이다.
유지보수성이란 두려움 없이, 주저함 없이, 저항감 없이 코드를 변경할 수 있는 능력을 말한다.

### 응집도
응집도는 모듈에 포함된 **내부 요소들이 연관되어 있는 정도**를 나타낸다. 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다. 모듈 내의 요소들이 서로 다른 목적을 추구한다면 그 모듈은 낮은 응집도를 가진다. 객체지향 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.

변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.
하나의 변경을 수용하기 위해 **모듈 전체가 함께 변경된다면 응집도가 높은 것**이고 모듈의 일부만 변경된다면 응집도가 낮은 것이다. 또한 **하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높지만** 다수의 모듈이 함께 변경되어야 한다면 응집도가 낮은 것이다.

코드 수정 후에 아무런 상관도 없던 코드에 문제가 발생하는 것은 모듈의 응집도가 낮을 때 발생하는 대표적인 증상이다.
### 결합도
결합도는 의존성의 정도를 나타내며 **다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지**를 나타내는 척도이다. 객체지향에서의 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다.

변경의 관점에서 결합도란 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다. 또한 내부 구현을 변경했을 때 이것이 다른 모듈에 영향을 미치는 경우를 결합도가 높다고 표현할 수도 있다.

**인터페이스에 대해 프로그래밍하라.**

## 캡슐화의 진정한 의미
캡슐화는 **변경될 수 있는 어떤 것이라도 감추는 것을 의미**한다. 흔히 생각하는 내부 속성을 외부로부터 감추는 것은 '데이터 캡슐화'라고 불리는 캡슐화의 한 종류일 뿐이다.

**설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화해야 한다.**